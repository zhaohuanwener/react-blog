export default [{
    "id": "5a2403226190c8912ebaceeb",
    "author_id": "4f447c2f0a8abae26e01b27d",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FhSNYCv6Ab9wzT6aUSfKLa0GtP4w\" alt=\"image.png\"></p>\n<blockquote>\n<p>原文地址：知乎专栏 <a href=\"https://zhuanlan.zhihu.com/p/31640541\">https://zhuanlan.zhihu.com/p/31640541</a></p>\n</blockquote>\n<p>给大家介绍下，Egg 2.0 正式版，今天 12.3 冒泡啦，距 3.21 的 <a href=\"https://zhuanlan.zhihu.com/p/25860846\">Egg 1.0 版本</a> 时隔 8 个月。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrC_ZbrhyLkhVIquPOsMqPhvqsHX\" alt=\"image.png\"></p>\n<blockquote>\n<p><a href=\"https://eggjs.org/\">Egg</a> 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。<br>\n既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。<br>\n它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。</p>\n</blockquote>\n<h2>2.0 特性</h2>\n<ul>\n<li>基于 Koa 2.x\n<ul>\n<li>异步解决方案直接基于 Async Function 。</li>\n<li>去除 co 兼容后<a href=\"https://github.com/eggjs/egg/wiki/co-vs-async\">堆栈信息更清晰</a>。</li>\n</ul>\n</li>\n<li>框架层优化带来 <a href=\"https://eggjs.github.io/benchmark/plot/\">30% 左右的性能提升</a>，不含 Node 8 带来的提升。</li>\n<li>为了方便开发者快速升级，保持了对 Egg 1.x 以及 generator function 的兼容。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fuf5DkXMxM7wfClcN6B6LzX5d18Q\" alt=\"image.png\"></p>\n<h2>如何升级</h2>\n<p><strong><a href=\"https://eggjs.org/\">Egg</a> 的理念之一是渐进式增强，故我们为开发者提供渐进升级的体验。</strong></p>\n<ol>\n<li>Node.js 使用最新的 LTS 版本（&gt;=8.9.0）。</li>\n<li>修改 package.json 中 egg 的依赖为 ^2.0.0。</li>\n<li>检查相关插件是否发布新版本（可选）。</li>\n<li>重新安装依赖，跑单元测试。</li>\n</ol>\n<p><strong>搞定！几乎不需要修改任何一行代码，就已经完成了升级。</strong></p>\n<p>这得益于 Egg 对 1.x 的兼容，但为了更好的统一代码风格，以及更佳的性能和错误堆栈，我们建议开发者参考 <a href=\"https://eggjs.org/zh-cn/migration.html\">升级指南</a> 进一步升级。</p>\n<h2>未来规划</h2>\n<p>如您所知，Egg 采用的是 <strong>『微内核 + 插件 + 上层框架』</strong> 模式。</p>\n<p>其中微内核经过 3 年 4 个版本，以及在阿里的大规模应用，已经打磨的非常稳定。</p>\n<p>接下来我们的<strong>重心主要在开发者体验方面的优化</strong>，包括：</p>\n<ul>\n<li>更好的开发者体验，包括 TypeScript，开发者工具，IDE 工具等方面。</li>\n<li>社区扶持\n<ul>\n<li>协助业界的前端团队，打造适合特定团队业务场景的上层框架，欢迎勾搭。</li>\n<li>分享我们在团队、协作、规范化等方面的经验。</li>\n<li>分享在 Docker，GraphQL，SSR 等方面的探索和最佳实践分享。</li>\n</ul>\n</li>\n<li>国际化，官网和<a href=\"https://github.com/eggjs/egg/issues/363\">文档翻译</a>等。</li>\n</ul>\n<p>同时，我们也欢迎社区更多的<a href=\"https://github.com/orgs/eggjs/projects\">参与</a>，一起打造更完善的生态。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fg_WHGNC13j2azgEWb-ONk5whle5\" alt=\"image.png\"></p>\n<h2>我们这一年</h2>\n<p>截止至今天(2017-12-03)：</p>\n<ul>\n<li><strong>GitHub 5.6k star</strong>，555 forks，npm 月下载量 11,140 (不含阿里内网数据)。</li>\n<li>从 1.0 到 2.0，我们一共发布了 <a href=\"https://github.com/eggjs/egg/releases\">18 个版本</a>，处理了 820 个 issue，收到了 500+ (主库 272) 个 Pull Request 。</li>\n<li>开发者体验方面的优化包括：<a href=\"https://eggjs.org/zh-cn/core/development.html#%E4%BD%BF%E7%94%A8-egg-bin-%E8%B0%83%E8%AF%95\">断点调试代理</a>，<a href=\"https://eggjs.org/zh-cn/core/development.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">单元测试+覆盖率</a>，<a href=\"https://eggjs.org/zh-cn/core/deployment.html#%E9%83%A8%E7%BD%B2\">部署工具</a>，TypeScript 支持，<a href=\"https://github.com/eggjs/vscode-eggjs\">VSCode 插件</a>，文档优化等等。</li>\n</ul>\n<p><strong>社区方面：</strong></p>\n<ul>\n<li>来自 BAT，丁香园，全民直播等多家兄弟公司的反馈和插件回馈。</li>\n<li>来自 <a href=\"https://github.com/eggjs/egg/network/dependents\">GitHub Dependents</a> 的统计：992 Repositories, 231 Packages</li>\n<li><a href=\"https://npms.io/search?q=egg-\">NPM 搜索结果</a>超过 400 个。</li>\n<li>上层框架：\n<ul>\n<li><a href=\"https://github.com/alibaba/beidou\">北斗</a> - Isomorphic framework for server-rendered React apps</li>\n<li><a href=\"https://github.com/avetjs/avet\">avet</a> - A very comfortable framework for writing isomorphic applications</li>\n</ul>\n</li>\n<li>如果你有好的分享，PR 传送门：<a href=\"https://github.com/eggjs/awesome-egg\">awesome-egg</a></li>\n</ul>\n<p><strong>趣味数据：</strong></p>\n<ul>\n<li>官网访问量中，Mac 占 47% → 这比例挺高的，看来 Node 程序猿都很幸福。</li>\n<li>周末的访问量约为平时的 1/3 → 看来 Node 程序猿周末加班少。（滑稽</li>\n<li>官网访问来源：站内，直链，外链各 30% 多，来自搜索引擎的较少。</li>\n</ul>\n<p><strong>分享交流：</strong></p>\n<ul>\n<li>在 <a href=\"http://2017.jsdc.tw/\">台灣 JSDC2017 開發者年會</a> 和 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了『<a href=\"https://github.com/atian25/blog/raw/master/assets/files/Egg%20%26%20Node.js%20%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%9D%8A%E8%B5%B0%E5%90%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91.pdf\">Egg &amp; Node.js 从小工坊走向企业级开发</a>』</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FgFUrGpNw07LKQPYzGgZp64j7CZH\" alt=\"image.png\"></p>\n<ul>\n<li>Node TSC @张秋怡 在 <a href=\"https://nina17.sched.com/event/Atii/nodejs-at-alibaba-a-joyee-cheung-alibaba-cloud\">Node Interactive North America 2017</a> 和 <a href=\"http://nodefest.jp/2017/schedule.html#joyee\">東京Node学園祭2017</a> 分享了『<a href=\"https://github.com/joyeecheung/talks/blob/master/node_fest_2017/nodejs_at_alibaba_tokyo.pdf\">Node.js at Alibaba</a>』。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fl5IyrfAMzQ49Uz3eQ67i2FLL09H\" alt=\"image.png\"></p>\n<ul>\n<li><a href=\"/user/ngot\">@ngot</a> 在 <a href=\"https://www.bagevent.com/event/751307\">Node Party</a> 分享了『<a href=\"https://github.com/Hangzhou-Node-Party/Node-Party/blob/master/2017-08-19/Egg.js%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E7%9A%84%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%90%E7%94%A8.pdf\">Egg.js 在阿里巴巴集团的实践运用</a>』</li>\n<li>@姜天意 在 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了 『<a href=\"https://github.com/jtyjty99999/share/blob/master/security%20risk%20in%20node%20web.pdf\">脆弱的 Node.js</a>』</li>\n</ul>\n<h2>写在最后</h2>\n<p>开源，痛并快乐着。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fiamh5LNYR3e2E0HtdhrO3sVfHrs\" alt=\"image.png\"></p>\n</div>",
    "title": "企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async",
    "last_reply_at": "2018-01-29T16:18:59.945Z",
    "good": true,
    "top": true,
    "reply_count": 105,
    "visit_count": 18410,
    "create_at": "2017-12-03T13:58:58.901Z",
    "author": {
        "loginname": "atian25",
        "avatar_url": "https://avatars1.githubusercontent.com/u/227713?v=3&s=120"
    }
}, {
    "id": "5a54a8a4afa0a121784a8ab0",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>很抱歉在首届蚂蚁体验科技 SEE Conf 大会上，给大家讲得有点磕绊不太清楚。今天写下来行诸文字，希望一些思考能与大家进一步交流。（设计师朋友可以跳过前端技术部分，直接看后面章节）</p>\n<h2>什么是前端技术</h2>\n<p>第一次接触前端开发是 2002 年大学期间，转眼 15 年多。这些年一直在思考一个问题：究竟什么是前端技术？很长很长一段时间，前端技术的定义非常清晰，就是浏览器端的 HTML、CSS、JS 技术。我们用这些技术做出各种各样的页面，我们是离用户最近的程序员。</p>\n<p><img src=\"//dn-cnode.qbox.me/FuTZzCUKkL_OGOsmrXbXvcqalO-D\" alt=\"v2-356e4bb976792ec0c2ae166405e4b502_hd.jpg\"></p>\n<p>记得 2009 年开始接触 Node，很快前端技术开始爆炸性增长。最开始的变化，是前端压缩工具从基于 Java 的 YUI Compressor 开始切换到基于 Node 实现的 UglifyJS 等工具。除了前端工具上的一路狂奔，在服务端领域也出现了 Express 等框架，前端开始通过 Node 完成服务端模板甚至整个 MVC 层的开发。在蚂蚁金服，服务端层我们更多把 Node 定位为 BFF 层实现，BFF 是 Backend For Frontend 的缩写，翻译成用户体验适配层。</p>\n<p>BFF 模式下，整体分工很清晰，后端通过 Java 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。</p>\n<p>除了服务端的渗透，从 2013 年开始，阿里开始无线 ALL IN 战略，这对前端影响非常大。有相当多的前端开始转型为 iOS 工程师（转型为 Android 的比较少，有部分 Java 工程师转型成了 Android 开发），没有转型的，也开始大量投入到 Mobile Web 开发。这个大背景下，前端与客户端技术开始互相融合，特别是在容器层。从 2015 年开始，物联网 IoT 逐步兴起，前端开始涉足 IoT 设备上的应用研发。端的本质是 devices，台式机、手机、IoT 设备都是一台台 devices，很多会直接被用户使用，有用户使用的 devices，就会有人机交互需求，就会有前端的工作价值。前端是离用户最近的工程师，这个定位一直没变。</p>\n<p>非常有意思的是，在移动端的架构里，这几年也出现了基于 RPC 接口 + 网关 + BFF 的架构体系，在研发效率、网络性能等方面均有优势。随着 IoT 应用的涌现与复杂化，我相信最终也会出现 BFF 架构。BFF 模式不仅仅是一种技术架构，从社会分工角度讲，BFF 更是一种多元价值导向的分层架构，每一层都有不错的空间去施展，不仅能发挥工业社会双手的作用，还能使用上双手上面的脑袋。齿轮不再是被动跟着转，而是开始拥有自驱的转动力。同一时期，业界也出现了一些类似的职业融合。比如 DevOps 倡导开发也懂运维，不少大公司在推行开发也懂测试，测试则转型为更专业的质量工具部门，还有前端也懂设计的 DesignOps 的出现等等。各种全栈概念的涌现，都是在重新探索更合理的分层协作模式。纷纷扰扰，成败如风。</p>\n<p>补充一个说明，当年提出的前后端分离，并不准确，这些年一直努力纠正为前后端分层的理念。专业的分工协同对效能的提升很关键。全栈的含义是指分层演化后，每一层的技术栈要求，是每一层横向技能的全，而不是纵向跨层的通（纵向跨多层都能通的人才非常少，就如当今社会已经非常难诞生博物学家了）。不断探索更好的分层协作是有意思的，这就如人类家庭里夫妻的关系一样，男权、女权都不可取，社会的演化最终会视人为人，每个个体平等、自由，社会会以一种必然的不可阻挡的形态往前演进。</p>\n<p>回到前端发展历史，前面说了这么多，只说了一件事，前后端分层协作的各种模式。协作的边界是数据，后端提供数据服务接口，前端消费数据实现人机交互。不同模式下，BaaS（Backend as a Service）的含义各有不同。在 BFF 模式下，由于 BFF 层的运维部署需要，前端还需负责 BFF 层的 PaaS 平台建设。不同模式下的工程体系各有不同，工程的本质是让一群人做好一堆事，涉及代码规范、协作流程、运维部署、性能与安全等很多领域，这里不再一一展开。</p>\n<p>服务端 Node 与各种终端的涌现，让前端进入了大前端范畴，这时候的前端，已远远不只是浏览器端的页面实现技术，而是后端服务与人机界面的连接器。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fgj5HsTiql9rambFQbhDg8t49tw3\" alt=\"v2-374230208f31483237155e80d46f1c0d_hd.jpg\"></p>\n<h2>什么是体验科技</h2>\n<p>我属于无线 ALL IN 战略中，选择留下来继续做 PC Web 的前端。虽然公司重点转向无线，但 PC 业务一直没停。随着近几年整个阿里集团“大中台、小前台”的策略，越来越多的企业级中后台产品处于兵荒马乱阶段，设计师非常缺失，随手一抓，都是大量体验比较糟心的产品。这过程中，越来越感觉什么地方有问题，一定在某些点上我们没做好。当时没多想，就想着既然缺设计师，我们就尝试去招聘。于是体验技术部开始拥有了设计师，非常艰辛的起步，非常感激的是，虽然艰辛，但找到了一些与我一样坚信中后台产品价值的设计师。一旦有了设计师，整个中后台产品的用户体验，一下子就提升上来了。</p>\n<p><img src=\"//dn-cnode.qbox.me/FvNAdF0m7cCZlevYQDFThuRYxvbz\" alt=\"v2-54abf60cd133916e016343ae4adaf376_hd.jpg\"></p>\n<p>设计团队的融入，日常的各种碰撞交流，让我的思维发生了很大变化。前端技术再牛，都很难直接解决产品层的用户体验。对中后台产品来说，设计的价值也远远不止于让产品的颜值提升，设计的更多更多价值，在于深入到产品的业务逻辑里去，去帮助业务梳理产品信息架构与任务流程。用户体验是一个非常综合的事，需要各种专业人士在同一个产品上聚焦发力，一起共同努力才能真正提升产品体验。设计师在这个过程中很痛苦，很多中后台产品都是非常垂直领域的业务产品，中间件、ECS、ODPS 等一堆堆专业术语让设计师们痛苦不堪，幸运的是，我们扛了过来。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fk5n__QHurYmZawYh6-UXJ5Ox0Tv\" alt=\"v2-9b693a1affab86f96e24e0bee03b3e90_hd.jpg\"></p>\n<p>接下来的故事，在今天各个讲师的分享里，不少都有提及。整个团队的重心，开始非常清晰地往几个方向发展：</p>\n<ul>\n<li>TWA 方向：这是比 BFF 更大的概念，上午不四的分享里有详细阐述，可参考 知乎专栏文章 。TWA 是 Techless Web App 的缩写，是一种技术理念，希望越来越多的开发者，可以不用再关注流程、构建、环境、部署等各种事，希望能做到技术无感化（Techless），让每一位开发着能安安静静的快乐编码。</li>\n<li>UI 智能化方向：Ant Design 是一个设计体系，antd 是 Ant Design 的 React 实现。这几年 antd 的发展，不仅让前端编码更快更爽了，同时让一个历史悠久但生生不息的领域重燃希望：是否存在人机交互界面智能可视化搭建的可能？这个领域，这一两年在阿里内部非常火，各种搭建产品层出不穷，目前都还处于比较垂直的领域，泛化到行业级通用的产品还没怎么出现。我们也开始尝试，而且我们相信天时地利人和，一定能折腾出点什么，正在努力中，或许在下次 SEE Conf 大会中会展示给大家。</li>\n<li>数据可视化方向：下午绝云和御术的分享，相信大家对 G2 和 AntV 已经有了一个整体了解。可视化方向我们是从 2014 年开始正式投入人员去做，最开始的想法来自科幻片，大家如果喜欢看科幻片的话，会留意到各种人机交互界面都是各种可视化效果了，很少很少有传统网页。可视化是个历史非常悠久的领域，我们小学时学会的乘法竖式，就是一种可视化，可以帮助我们减少记忆成本，同时提升计算速度。</li>\n<li>图形互动化方向： 上午好修和景夫有分享，这一块才开始一年多，是我们非常笃定的一个方向。很多小孩，对书本都比较抗拒，但对游戏有着天生的喜爱。蚂蚁森林让大家从表单形式的公益，变成了互动游戏型的公益。越来越多的人机交互形式，会是有互动交互的图形界面。应用的泛互动化，是一个很大趋势。支付宝是个生活服务平台，各种生活服务的互动有趣化，一定是更有吸引力的。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fui53ymFhJc0JS0IA0ZXqUvBNFiQ\" alt=\"v2-6830ebf2ca603dca8bd33723d73220e3_hd.jpg\"></p>\n<p>看更远的未来，我相信对体验科技来说，自然化和虚拟化会是两个大趋势。</p>\n<p>我现在在分享这个 PPT，要翻页时，需要点击键盘按钮，为什么电脑不能直接理解我的意图而自动翻页呢？比如我只要头往下示意一下，就能自然而然翻到下一页。我们现在很多行为，跳脱出来看，能发现很多很多不自然。天猫精灵等各种智能音箱，真正去用时，离自然交互还有比较远的距离。Ant Design 设计价值观里，最最重要的就是自然价值观，一切才刚刚开始探索。</p>\n<p>再说虚拟化。虚拟化不仅仅指 AR、VR 等技术，看过黑客帝国、西部世界等科幻片的，会对虚拟化有更多体感。如果以后每个小孩出生时，就会被植入一个能五感俱全的芯片，这种情况下，我们的人机交互会是怎么样的。太多可能性与挑战在等着我们。</p>\n<p>这一切都是体验科技，是技术与设计的融合，是服务与用户连接，是下图中的一个公式。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fh5rgc3RVIRYuQYZSXMdKlBKlfnB\" alt=\"v2-773def061a6dd38cd97c52f040da29cc_hd.jpg\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FpueJ6H7sBiB7kVsLORMYQpjDClK\" alt=\"v2-e4186cd37a1f978abbf64970dee50ba9_hd.jpg\"></p>\n<p>体验科技是 UX = f(services) 这个公式，能将各种各种的 services（后端服务） 通过技术与设计的融合，转变成体验一流的用户产品。这个公式的一个实现，就是蚂蚁体验云。蚂蚁体验云的初心，是希望能帮助有梦想的你，将一个个优秀的想法，通过体验云实现成一个个终端产品。\n<img src=\"//dn-cnode.qbox.me/FjtnnNqNeyh5rH4MTreunWUgsNgj\" alt=\"v2-ab3eae986630f436d1c6b751f4a8d895_hd.jpg\"></p>\n<p>体验云才刚刚起步，目前已在内部服务蚂蚁金服、阿里巴巴集团，同时快速孵化出了云凤蝶、语雀、小钱袋等创新产品。虽然还很不完善，但我们希望能尽快与用户一起成长。很多激动人心的事正在发生，通过体验科技的开放，我们希望着能为世界带来更多平等的机会。\n<img src=\"//dn-cnode.qbox.me/FgGx0MFi9k0eJAeLX3icMz6YLD9v\" alt=\"v2-98323a7d1c563df55151451066a7709e_hd.jpg\"></p>\n<p>感谢聆听，期待交流。</p>\n<p>附 SEE Conf 演讲视频： <a href=\"http://v.youku.com/v_show/id_XMzMwMzg2MDIwOA==.html\">优酷地址 </a></p>\n<p>最后，演讲 PPT 已精心整理并转换为 PDF 上传至<a href=\"http://yuque.com/seeconf\"> SEE Conf 语雀在线知识库</a>，欢迎下载（请 注册语雀，个人描述内注明 #知乎seeconf# 便可快速申请邀请码，登录后即可下载）</p>\n</div>",
    "title": "玉伯《从前端技术到体验科技（附演讲视频）》",
    "last_reply_at": "2018-01-24T06:49:43.526Z",
    "good": false,
    "top": true,
    "reply_count": 18,
    "visit_count": 6187,
    "create_at": "2018-01-09T11:33:56.183Z",
    "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
    }
}, {
    "id": "592917b59e32cc84569a7458",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n<li><a href=\"https://cnodejs.org/user/h5-17\">https://cnodejs.org/user/h5-17</a> <a href=\"/user/h5-17\">@h5-17</a></li>\n<li><a href=\"https://cnodejs.org/user/592php\">https://cnodejs.org/user/592php</a> <a href=\"/user/592php\">@592php</a></li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>",
    "title": "测试请发到客户端测试专区，违规影响用户的，直接封号",
    "last_reply_at": "2018-01-03T15:43:22.119Z",
    "good": false,
    "top": true,
    "reply_count": 147,
    "visit_count": 37552,
    "create_at": "2017-05-27T06:07:49.278Z",
    "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
    }
}, {
    "id": "5a6fe5199d371d4a059eefb2",
    "author_id": "5a0b14fd310be7561d4c048d",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>如果修改单个用户信息的api如下:\nput /api/user/1</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;name&quot;: &quot;tom&quot;,\n  &quot;addr&quot;: &quot;北京&quot;\n}\n</code></pre><p>那么通过直觉去想, 批量修改用户的api应该这样设计:\nput /api/user</p>\n<pre class=\"prettyprint language-json\"><code>[\n  {\n    &quot;name&quot;: &quot;tom&quot;,\n    &quot;addr&quot;: &quot;北京&quot;\n  },\n  {\n    &quot;name&quot;: &quot;Obama&quot;,\n    &quot;addr&quot;: &quot;大连&quot;\n  }\n]\n</code></pre><p>但是这样设计好像不符合RESTful的url必须是资源的设计, 请问大家是怎么设计的呢? 谢谢!</p>\n</div>",
    "title": "请问使用RESTful设计API时, 对于批量修改的数据应该怎么设计?",
    "last_reply_at": "2018-01-30T03:23:05.955Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 6,
    "create_at": "2018-01-30T03:23:05.955Z",
    "author": {
        "loginname": "x22x22",
        "avatar_url": "https://avatars2.githubusercontent.com/u/3389949?v=4&s=120"
    }
}, {
    "id": "5a6fe1eaafa0a121784a9116",
    "author_id": "59588bdf545d7a7b5b0b389f",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><blockquote>\n<p>一言不合就造轮子，适合自己的轮子才是好轮子。</p>\n</blockquote>\n<p>在写koa的时候，自己造了个日志打印工具，现在分享出来给喜欢的朋友。</p>\n<p><strong>node-bugjs</strong> 是 node.js 的一个调试工具。</p>\n<ul>\n<li>支持5中主题样式（白，红，绿，黄，蓝）</li>\n<li>显示当前输出日志代码行号，方便开发调试</li>\n<li>支持定义log回调处理，实现log记录功能</li>\n</ul>\n<pre class=\"prettyprint language-bat\"><code>npm install -S node-bugjs\n</code></pre><pre class=\"prettyprint language-js\"><code>const bugjs = require(&#x27;node-bugjs&#x27;)(&#x27;demo&#x27;)\nbug.log(&#x27;wellcome&#x27;)\n</code></pre><p>更详细用法请看 <a href=\"https://github.com/mengdu/node-bugjs\">README.md</a></p>\n<p><img src=\"//dn-cnode.qbox.me/Fr6aFEAlB_wdTpL30aixsok3rZR0\" alt=\"untitled1.png\"></p>\n<p>koa中使用\n<img src=\"//dn-cnode.qbox.me/FoVODY9QzAxvpHy5Ua72QV4TC7Ny\" alt=\"untitled2.png\"></p>\n</div>",
    "title": "写一个更具特色的node日志工具包",
    "last_reply_at": "2018-01-30T03:09:30.400Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 13,
    "create_at": "2018-01-30T03:09:30.400Z",
    "author": {
        "loginname": "mengdu",
        "avatar_url": "https://avatars0.githubusercontent.com/u/11366654?v=4&s=120"
    }
}, {
    "id": "581b2502e90cfbec054d763f",
    "author_id": "57df88ff7d8293463a01e70b",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h1>都说用Nodejs来生成验证码效率很低下，但有时候你仍然需要用node来生成验证码</h1>\n<h2>注：此技术现在已经拆分成独立模块了</h2>\n<h3>安装方法为npm install gd-bmp，参考gd-bmp模块下的demo</h3>\n<p><img src=\"//dn-cnode.qbox.me/FhpoxAGx3MEB_WcVbzkYlHaAD6f8\" alt=\"百度搜索.jpg\">\n点开百度搜索结果的第一条，找到三个模块：\n1.node-canvas\n2.node-gyp\n3.ccap\n看描述，这些无一例外需要安装其它支持库（C或C++编写，平台兼容性极差）\n<strong>我个人认为一切需要安装额外支持库的模块都是耍流氓！</strong>\n搜索结果比较多的是CCAP, 而ccap的介绍：\n<a href=\"https://cnodejs.org/topic/50f90d8edf9e9fcc58a5ee0b\">https://cnodejs.org/topic/50f90d8edf9e9fcc58a5ee0b</a>\n在提到性能时，是这样写的：\n在2cpu的linux 64位服务器上生成验证码速度可以达到1200次/秒，测试生成的图片是BMP的，jpeg的图片验证码生成速度大约在600次/秒。\n也<strong>仅仅达到1200次/秒</strong></p>\n<p><strong>为什么需要完全用js来实现图形模块？在node本身没有提供图形库的情况下，只有完全用js编写的图形库能做到在任何平台上运行的效果一致，实测，我的模块可以在openwrt路由器上完美运行！</strong>\n我测试了另外一款全js实现的验证码生成模块（图形操作很有限，没有画点、线等一些基本功能，甚至颜色设置也很差）\ncaptchapng\n<strong>在我的电脑上测试</strong>：（node版本4.4.4，32位CPU双核2.0G主频）\n按照所给的demo，生成的是80x30的验证码，900张/秒\n而我的生成的是100x40的验证码，可以达到<strong>2400张/秒</strong>\n<img src=\"//dn-cnode.qbox.me/FmxlVb-GgPlEGKMN0SCSU6mE0apf\" alt=\"captchapng测试.jpg\">\n<strong>在openwrt路由器上测试</strong>：（只有完全用js编写的模块可以在路由器上运行！ccap之类的是绝对无法运行的）\n同样的代码\ncaptchapng是7张/秒\n我的模块是7张/秒\n路由器的型号是TP-WR841N V10，硬改内存64M，CPU超频到850M，node版本4.4.5\n之所以说ccap之类的是绝对无法运行，因为路由器的node运行环境非常极端！内存极少，CPU指令与电脑是完全不同的\n所以依赖C/C++支持的模块是无法运行的！甚至代码量过大的js程序也无法运行，例如使用npm安装express，由于express需要依赖太多其它模块，导致npm的运行没有足够的内存</p>\n<p><strong>以下是我对captchapng的测试代码  png.js</strong></p>\n<pre class=\"prettyprint language-js\"><code>var http = require(&#x27;http&#x27;);\nvar captchapng = require(&#x27;captchapng&#x27;);\n&#x2F;&#x2F;captchapng版本 0.0.1\n\nfunction getImg(){\n\t    var p = new captchapng(80,30,parseInt(Math.random()*9000+1000)); &#x2F;&#x2F; width,height,numeric captcha\n        p.color(0, 0, 0, 0);  &#x2F;&#x2F; First color: background (red, green, blue, alpha)\n        p.color(80, 80, 80, 255); &#x2F;&#x2F; Second color: paint (red, green, blue, alpha)\n\n        var img = p.getBase64();\n        var imgbase64 = new Buffer(img,&#x27;base64&#x27;);\n\t\treturn imgbase64;\n}\n\nvar start = new Date().getTime();\nvar i = 0;\nwhile((new Date().getTime() - start) &lt; 1000){\n    var img = getImg();\n    i++;\n}\nconsole.log(&quot;1秒钟生成：&quot; + i);\n\n\nhttp.createServer(function (request, response) {\n        response.writeHead(200, {\n            &#x27;Content-Type&#x27;: &#x27;image&#x2F;png&#x27;\n        });\n\t\tvar img = getImg();\n        response.end(img);\n\n}).listen(8080);\n\nconsole.log(&#x27;Web server started.&#x27;);\n</code></pre><h3>好了，现在来介绍一下我花了两天时间编写的“图形库”</h3>\n<p>字符图形测试：\n<img src=\"//dn-cnode.qbox.me/FsmPagKHWmJN8UoWwJD6Nh-ab0uU\" alt=\"字符测试.jpg\">\n验证码：\n<img src=\"//dn-cnode.qbox.me/FqRA25HwmCbhQXY4ZGVTjZvJLh9D\" alt=\"验证码1.jpg\">   <img src=\"//dn-cnode.qbox.me/Fs9K8Ck-jMGDQjQiBebkEhlcJpJH\" alt=\"验证码2.jpg\">\n匆忙做出来的，样子很难看，图片大小和百度云网盘登录的验证码是一样的，都是100x40\n其实我编写的是一个只能操作24位bmp图片的“图形库”，大家都知道bmp图片是没有压缩的，\n所以文件大小必定会比jpg，gif，png之类的大，但是，对于验证码仅仅100x40的图片来说仅仅11.7K，微不足道！\n况且，用Js来编写操作这些格式的程序太过复杂。\n实测在我的电脑上可以达到2400张/秒的优秀成绩（我的电脑是32位 CPU双核2G主频）\n假如去除上面验证码中的正弦曲线，可以达到6500张/秒！\n假如同时去除字符和正弦曲线只保留画圆、画线、画空心矩形和实心矩形，可以达到<strong>12000张/秒！</strong></p>\n<h3>安装</h3>\n<p>npm install zengming\n我个人的测试模块，呵呵，有时间再把这个&quot;图形库&quot;拆分出来</p>\n<p><strong>现在已经拆分成独立模块了：</strong>\nnpm install gd-bmp\ngithub地址： <a href=\"https://github.com/zengming00/node-gd-bmp\">https://github.com/zengming00/node-gd-bmp</a>\n使用与zengming模块基本一致，只是将字体和类绑在了一起，细微的差异请参考gd-bmp模块下的demo</p>\n<h3>测试代码 bmp.js</h3>\n<pre class=\"prettyprint language-js\"><code>var http = require(&#x27;http&#x27;);\nvar fs = require(&#x27;fs&#x27;);\nvar z = require(&#x27;zengming&#x27;);\nvar BMP24 = z.BMP24;\nvar font = z.Font;\n\n&#x2F;*\n 用PCtoLCD2002取字模\n 行列式扫描，正向取模（高位在前）\n *&#x2F;\nvar cnfonts = {&#x2F;&#x2F;自定义字模\n    w : 16,\n    h : 16,\n    fonts: &quot;中国&quot;,\n    data : [\n        [0x01,0x01,0x01,0x01,0x3F,0x21,0x21,0x21,0x21,0x21,0x3F,0x21,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0xF8,0x08,0x08,0x08,0x08,0x08,0xF8,0x08,0x00,0x00,0x00,0x00],&#x2F;*&quot;中&quot;,0*&#x2F;\n        [0x00,0x7F,0x40,0x40,0x5F,0x41,0x41,0x4F,0x41,0x41,0x41,0x5F,0x40,0x40,0x7F,0x40,0x00,0xFC,0x04,0x04,0xF4,0x04,0x04,0xE4,0x04,0x44,0x24,0xF4,0x04,0x04,0xFC,0x04],&#x2F;*&quot;国&quot;,1*&#x2F;\n        ]\n};\n\nfunction makeImg2() {\n    var img = new BMP24(300,140);\n    img.drawString(&#x27;helloworld&#x27;, 20,10, font.font8x16, 0xff0000);\n    img.drawString(&#x27;helloworld&#x27;, 20,25, font.font12x24, 0x00ff00);\n    img.drawString(&#x27;helloworld&#x27;, 20,50, font.font16x32, 0x0000ff);\n    img.drawString(&#x27;中国&#x27;, 20,85, cnfonts, 0xffffff);\n    return img;\n}\n\nfunction makeCapcha() {\n    var img = new BMP24(100, 40);\n    img.drawCircle(11, 11, 10, z.rand(0, 0xffffff));\n    img.drawRect(0, 0, img.w-1, img.h-1, z.rand(0, 0xffffff));\n    img.fillRect(53, 15, 88, 35, z.rand(0, 0xffffff));\n    img.drawLine(50, 6, 3, 60, z.rand(0, 0xffffff));\n    &#x2F;&#x2F;return img;\n\n    &#x2F;&#x2F;画曲线\n    var w=img.w&#x2F;2;\n    var h=img.h;\n    var color = z.rand(0, 0xffffff);\n    var y1=z.rand(-5,5); &#x2F;&#x2F;Y轴位置调整\n    var w2=z.rand(10,15); &#x2F;&#x2F;数值越小频率越高\n    var h3=z.rand(4,6); &#x2F;&#x2F;数值越小幅度越大\n    var bl = z.rand(1,5);\n    for(var i=-w; i&lt;w; i+=0.1) {\n        var y = Math.floor(h&#x2F;h3*Math.sin(i&#x2F;w2)+h&#x2F;2+y1);\n        var x = Math.floor(i+w);\n        for(var j=0; j&lt;bl; j++){\n            img.drawPoint(x, y+j, color);\n        }\n    }\n\n    var p = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ3456789&quot;;\n    var str = &#x27;&#x27;;\n    for(var i=0; i&lt;5; i++){\n        str += p.charAt(Math.random() * p.length |0);\n    }\n\n    var fonts = [font.font8x16, font.font12x24, font.font16x32];\n    var x = 15, y=8;\n    for(var i=0; i&lt;str.length; i++){\n        var f = fonts[Math.random() * fonts.length |0];\n        y = 8 + z.rand(-10, 10);\n        img.drawChar(str[i], x, y, f, z.rand(0, 0xffffff));\n        x += f.w + z.rand(2, 8);\n    }\n    return img;\n}\nvar start = new Date().getTime();\nvar i = 0;\nwhile((new Date().getTime() - start) &lt; 1000){\n    &#x2F;&#x2F;var img = makeCapcha();\n    var img = makeImg2();\n    i++;\n}\nconsole.log(&quot;1秒钟生成：&quot; + i);\n\nhttp.createServer(function (req,res) {\n    console.time(&quot;bmp24&quot;);\n    var img = makeCapcha();\n    console.timeEnd(&quot;bmp24&quot;);\n\n    res.setHeader(&#x27;Content-Type&#x27;, &#x27;image&#x2F;bmp&#x27;);\n    res.end(img.getFileData());\n\n}).listen(8080);\n\n</code></pre><h2>以上的代码使用了此模块的所有功能，特别说明一下，字符的显示借鉴了单片机的字符显示程序\n所以字符是完全可以自定义的，你可以用取字模的软件自己生成字库，\n我用的是PCtoLCD2002取字模， 行列式扫描，正向取模（高位在前）\n程序已经内置了三种规格的字体，仅包含大小写字母和数字</h2>\n<h3>API，非常简洁、强大、优雅、风骚、时尚、一看就懂，前无古人后无来者</h3>\n<p>//获得对象的两种方式：\n//构造函数，创建指定宽高的图片对象(初始化为一张全黑的图片)\nnew BMP24(w, h)</p>\n<p>从文件加载bmp\n注意！必需确保文件是24位bmp\n参数：文件路径 ， cb(err, BMP24)\nBMP24.loadFromFile(filename, cb)</p>\n<hr>\n<p>//获取BMP整个文件数据\nobj.getFileData()</p>\n<p>//画点, RGB颜色值（例如红色0xff0000）\nobj.drawPoint(x, y, rgb)</p>\n<p>//画线\nobj.drawLine(x1, y1, x2, y2, rgb)</p>\n<p>//画矩形&amp;实心矩形\nobj.drawRect(x1, y1, x2, y2, rgb)\nobj.fillRect(x1, y1, x2, y2, rgb)</p>\n<p>//画圆\nobj.drawCircle(x, y, r, rgb)</p>\n<p>//画字符&amp;字符串，font参数为字库，color为RGB颜色值（例如红色0xff0000）\nobj.drawChar(ch, x, y, font, color)\nobj.drawString(str, x, y, font, color)</p>\n<h1>license</h1>\n<h2>MIT,  导致一个人低学历的原因有很多，学历不代表一个人的全部，面试几家全是以学历不够为由打下来，我决定不授权此项技术给任何看学历的公司使用</h2>\n<hr>\n</div>",
    "title": "彻底跨平台，Node.js高效生成验证码，我自己用纯js实现了一个图形模块",
    "last_reply_at": "2018-01-30T03:08:59.131Z",
    "good": false,
    "top": false,
    "reply_count": 68,
    "visit_count": 59334,
    "create_at": "2016-11-03T11:52:34.473Z",
    "author": {
        "loginname": "zengming00",
        "avatar_url": "https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"
    }
}, {
    "id": "5a6fe00e9d371d4a059eefae",
    "author_id": "577b16e64e3c2a8305cc0e54",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>配置如下，debug查看中间件已经生效且ctx.request.url 地址已经更改，但是并未跳转。</p>\n<pre class=\"prettyprint language- javascript\"><code>&#x2F;&#x2F; middleware \nmodule.exports = require(&#x27;koa-connect-history-api-fallback&#x27;);\n</code></pre><pre class=\"prettyprint language- javascript\"><code>&#x2F;&#x2F; config.defalut.js \nconfig.middleware = [&#x27;historyFallback&#x27;, &#x27;errorHandler&#x27;];\nconfig.historyFallback = {\n\tindex: &#x27;&#x2F;public&#x2F;index.html&#x27;\n};\n</code></pre><pre class=\"prettyprint language- javascript\"><code>&#x2F;&#x2F; 这是执行中间件后的 ctx.request\n{ method: &#x27;GET&#x27;,\n  url: &#x27;&#x2F;public&#x2F;index.html&#x27;,\n  header:\n   { host: &#x27;localhost:7001&#x27;,\n     connection: &#x27;keep-alive&#x27;,\n     pragma: &#x27;no-cache&#x27;,\n     &#x27;cache-control&#x27;: &#x27;no-cache&#x27;,\n     &#x27;upgrade-insecure-requests&#x27;: &#x27;1&#x27;,\n     &#x27;user-agent&#x27;: &#x27;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;63.0.3239.132 Safari&#x2F;537.36&#x27;,\n     accept: &#x27;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q=0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q=0.8&#x27;,\n     &#x27;accept-encoding&#x27;: &#x27;gzip, deflate, br&#x27;,\n     &#x27;accept-language&#x27;: &#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;,\n     cookie: &#x27;csrfToken=P4G9quEQSrr_rATJnx7vjAI7; locale=en-us&#x27; } }\n</code></pre></div>",
    "title": "如何在egg中使用 koa-connect-history-api-fallback 中间件？",
    "last_reply_at": "2018-01-30T03:01:34.547Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 19,
    "create_at": "2018-01-30T03:01:34.547Z",
    "author": {
        "loginname": "yanfch",
        "avatar_url": "https://avatars3.githubusercontent.com/u/10338055?v=4&s=120"
    }
}, {
    "id": "5a6c66449288dc81532882ba",
    "author_id": "59588bdf545d7a7b5b0b389f",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>为自己这套http://vadmin.lanyueos.com模板写个vuex的例子，然后就拿cnode接口写了cnode首页。</p>\n<p><a href=\"http://vadmin.lanyueos.com/cnode\">传送门</a>\n<img src=\"//dn-cnode.qbox.me/FvCPxUE-VLPpMKLIac5hx_u0R9p-\" alt=\"image.png\"></p>\n<p><a href=\"https://github.com/mengdu/vue-element-admin-tpl\">vue-element-admin-tpl</a> 这个模板我是我工作和平时开发的积累，可以快速搭建后台管理平台系统的模板。\n我会不定期更新这个模板，欢迎star。</p>\n</div>",
    "title": "用vue写了一cnode首页，不一样的风格哦",
    "last_reply_at": "2018-01-30T02:57:28.699Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 506,
    "create_at": "2018-01-27T11:45:08.073Z",
    "author": {
        "loginname": "mengdu",
        "avatar_url": "https://avatars0.githubusercontent.com/u/11366654?v=4&s=120"
    }
}, {
    "id": "5a6e9119ce45d4404514648f",
    "author_id": "591e3dd29e32cc84569a7109",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>原来的是定义了这样一个方法：</p>\n<pre class=\"prettyprint\"><code>let reactionScheduler: (fn: () =&gt; void) =&gt; void = f =&gt; f()\n</code></pre><p>看了好久没看懂这个方法干哈用的，于是就拿去跑一下编译，结果出来的结果更是让我不能理解。 \t\n结果如下：</p>\n<pre class=\"prettyprint\"><code>var reactionScheduler = function (f) { return f(); };\n</code></pre><p>有没有大神给剖析一把上面的方法。 \t\n再一个问题是，定义这个方法的意义在哪里？</p>\n</div>",
    "title": "看到一个typescript方法，不能理解，看了编译结果，更不能理解了",
    "last_reply_at": "2018-01-30T02:50:10.877Z",
    "good": false,
    "top": false,
    "reply_count": 7,
    "visit_count": 288,
    "create_at": "2018-01-29T03:12:25.449Z",
    "author": {
        "loginname": "wangchaoduo",
        "avatar_url": "https://avatars0.githubusercontent.com/u/16484068?v=4&s=120"
    }
}, {
    "id": "5a6fd3a49d371d4a059eefa2",
    "author_id": "57b08034a4f7e29c763413ef",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>具体问题见<a href=\"https://www.v2ex.com/t/317678\">测试案例</a>\n延时会随着压测并发量增大而增大</p>\n<h1>测试命令</h1>\n<p>ab -n 1000 -c 200 -r <a href=\"http://localhost:8080/proxy-api\">http://localhost:8080/proxy-api</a>\nwebbench -t 10 -c 500 <a href=\"http://localhost:8080/proxy-api\">http://localhost:8080/proxy-api</a></p>\n<h1>截取部分响应耗时：</h1>\n<p>get <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2019 ms\ncost time:  2020\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2062 ms\ncost time:  2062\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2064 ms\ncost time:  2065\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2063 ms\ncost time:  2063\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2062 ms\ncost time:  2063\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2063 ms\ncost time:  2063\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2061 ms\ncost time:  2062\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2063 ms\ncost time:  2064\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 2063 ms\n…\n…\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1362 ms\ncost time:  1362\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1361 ms\ncost time:  1362\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1362 ms\ncost time:  1362\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1362 ms\ncost time:  1362\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1362 ms\ncost time:  1362\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1363 ms\ncost time:  1363\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1362 ms\ncost time:  1362\n…\n…\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1006 ms\ncost time:  1006\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 627 ms\ncost time:  628\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 629 ms\ncost time:  629\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 628 ms\ncost time:  629\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1403 ms\ncost time:  1403\nget <a href=\"http://ip:9190/user/getUserInfo\">http://ip:9190/user/getUserInfo</a> 1402 ms</p>\n</div>",
    "title": "node 进行高并发接口透传，会出现延时增加问题",
    "last_reply_at": "2018-01-30T02:27:29.584Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 71,
    "create_at": "2018-01-30T02:08:36.074Z",
    "author": {
        "loginname": "lvgithub",
        "avatar_url": "https://avatars1.githubusercontent.com/u/16065346?v=4&s=120"
    }
}, {
    "id": "5a6f3c199d371d4a059eef98",
    "author_id": "58628449e8013c6b392b0bd0",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>用下面的代码简单的搭建一个静态资源服务，static目录包含<img src=\"//dn-cnode.qbox.me/FkZZJcPFt4ejOEwXPI4FCB2jCQgd\" alt=\"111111.png\">，</p>\n<p>访问localhost:3000显示的是index.html内容，没有static目录的列表像这样这种：\n<img src=\"//dn-cnode.qbox.me/FueNyOnyY3RvcRSPoxvkUieIs7qI\" alt=\"222222.png\">，</p>\n<p>但是访问具体的文件都可以访问到，就是没办法显示整个列表，这样正常么？</p>\n<pre class=\"prettyprint language-js\"><code>const Koa = require(&#x27;koa&#x27;)\nconst path = require(&#x27;path&#x27;)\nconst static = require(&#x27;koa-static&#x27;)\nconst app = new Koa() \nconst staticPath = &#x27;.&#x2F;static&#x27;\napp.use(static(path.join(__dirname, staticPath)))\napp.use(async (ctx) =&gt; {\n    ctx.body = &#x27;hello world&#x27;\n})\napp.listen(3000)\n</code></pre></div>",
    "title": "用 koa-static 搭建静态资服务器没法显示文件列表吗？",
    "last_reply_at": "2018-01-30T02:13:04.048Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 110,
    "create_at": "2018-01-29T15:22:01.346Z",
    "author": {
        "loginname": "ouyangxuanyun",
        "avatar_url": "https://avatars3.githubusercontent.com/u/10010617?v=4&s=120"
    }
}, {
    "id": "5a6e1d569d371d4a059eef41",
    "author_id": "503a6618f767cc9a5104139c",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FvDiF-U9QKBZu_Es1cpg0hlFNoAc\" alt=\"屏幕快照 2018-01-29 上午2.45.30.png\"></p>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余。</p>\n<p>想更多的了解或使用 GraphQL，请访问 <a href=\"https://github.com/facebook/graphql\">https://github.com/facebook/graphql</a></p>\n<p>GraphQL 有针对不同语言的服务端实现，以帮助开发人员搭建  <code>GraphQL Server</code>。</p>\n<p>而 <code>gq-loader</code> 是一个 <code>webpack</code> 插件，你可以认为它一针对前端项目的一种 <code>client</code> 端实现，它的目的是帮助前端开发同学更简便的调用 GraphQL API，它让前端开发人员在使用 GraphQL 时更加方便，像普通 <code>js</code> 模块一样轻松自如，使前端开发人员能在 <code>js</code> 文件中通过 <code>import</code> 或 <code>require</code> 导入 <code>.gql</code> 和 <code>.graphql</code> 文件，然后直接调用。 并且它还支持通过 <code>#import</code> 语法导入其它 <code>.gql</code> 文件，比如 fragments。</p>\n<blockquote>\n<p><code>#import</code> 还提供了两个别名，分别是 <code>#require</code> 和 <code>#include</code>，这两个别名和 <code>#import</code> 的用法及行为完全一致。</p>\n</blockquote>\n<p><strong>关注或使用 <code>gq-loader</code></strong>，请移步 GitHub：<a href=\"https://github.com/Houfeng/gq-loader\">https://github.com/Houfeng/gq-loader</a></p>\n<h2>安装</h2>\n<pre class=\"prettyprint\"><code>npm install gq-loader --save-dev\n</code></pre><p>或者</p>\n<pre class=\"prettyprint\"><code>yarn add gq-loader\n</code></pre><h2>基本使用</h2>\n<p>如同其它 loader 一样，首先，我们在 <code>webpack.config.js</code> 中添加 <code>gq-loader</code> 的配置</p>\n<pre class=\"prettyprint language-js\"><code>{\n  test: &#x2F;\\.(graphql|gql)$&#x2F;,\n  exclude: &#x2F;node_modules&#x2F;,\n  use: {\n    loader: &#x27;gq-loader&#x27;\n    options: {\n      url: &#x27;Graphql Server URL&#x27;\n    }\n  }\n}\n</code></pre><p>然后，我们就可以在 <code>js</code> 文件中通过 <code>import</code> 来导入 <code>.gql</code> 文件使用它了，我们来一个简单的示例，假设已经有一个可以工作的 <code>Graphql Server</code>，那么，我们先创建一个可以查询用户的 <code>getUser.gql</code></p>\n<pre class=\"prettyprint language-gql\"><code>#import &#x27;.&#x2F;fragment.gql&#x27; \n\nquery MyQuery($name: String) {\n  getUser(name: $name)\n    ...userFields\n  }\n}\n</code></pre><p>可以看到，我们通过 <code>#import</code> 引用了另外一个 <code>.gql</code> 文件 <code>fragment.gql</code>，在这个文件中我们描术了要返回的 user 的字段信息，这样我们就能在不同的地方「重用」它了，我们也创建一下这个文件</p>\n<pre class=\"prettyprint language-gql\"><code>fragment userFields on User {\n  name\n  age\n}\n</code></pre><p>好了，我们可以在 <code>js</code> 文件中直接导入 <code>getUser.gql</code>，并且使用它查询用户了，从未如此简便，我们来看看</p>\n<pre class=\"prettyprint language-js\"><code>import getUser from &#x27;.&#x2F;getUser.gql&#x27;;\nimport React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\n\nasync function query() {\n  const user = await getUser({ name: &#x27;bob&#x27; });\n  console.log(&#x27;user&#x27;, user);\n}\n\nfunction App() {\n  return &lt;button onClick={query}&gt;click&lt;&#x2F;button&gt;;\n}\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n</code></pre><p>在调用 <code>getUser</code> 时，我们可以给函数参数向 <code>GraphQL</code> 传递变量，这些变量就是我们的查询参数。</p>\n<h2>自定义请求</h2>\n<p>默认 <code>gq-loader</code> 就会帮你完成 <code>graphql 请求</code>，但某些场景下或许你想自已控制所有请求，如果有这样需要，我们还可以通过 <code>request</code> 属性来「自定义」请求，看一下示例，需要先稍微改动一下 <code>loader 配置</code></p>\n<pre class=\"prettyprint language-js\"><code>{\n  test: &#x2F;\\.(graphql|gql)$&#x2F;,\n  exclude: &#x2F;node_modules&#x2F;,\n  use: {\n    loader: &#x27;gq-loader&#x27;\n    options: {\n      url: &#x27;Graphql Server URL&#x27;,\n      &#x2F;&#x2F;指定自动请求模块路径\n      request: require.resolve(&#x27;your_request_module_path&#x27;);\n    }\n  }\n}\n</code></pre><p>在 <code>your_request_module_path</code> 填写自定义请求模块路径，<code>gq-loader</code> 将自动加载并使用对应请求模块，模块只需要改出一个「请求函数即可」，看如下自定义示例</p>\n<pre class=\"prettyprint language-js\"><code>const $ = require(&#x27;jquery&#x27;);\n\n&#x2F;&#x2F;url 是要请求的 GraphQL 服务地址\n&#x2F;&#x2F;data 是待发送的数据\n&#x2F;&#x2F;options 是自定义选项\nmodule.exports = function(url, data, options){\n  &#x2F;&#x2F;如果有需要还可以处理 options\n  return $.post(url, data);\n};\n</code></pre><p>其中，<code>options</code> 是导入 <code>.gql</code> 文件后「函数的第二个参数」，比如，可以这样传递 <code>options</code> 参数</p>\n<pre class=\"prettyprint language-js\"><code>import getUser from &#x27;.&#x2F;getUser.gql&#x27;;\n\nasync function query() {\n  const options = {...};\n  const user = await getUser({ name: &#x27;bob&#x27; }, options);\n  console.log(&#x27;user&#x27;, user);\n}\n</code></pre><h2>完整选项</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>URL</td>\n<td>指定 graphql 服务 URL</td>\n<td>/graphql</td>\n</tr>\n<tr>\n<td>request</td>\n<td>自定义请求函数</td>\n<td>使用内建模块</td>\n</tr>\n<tr>\n<td>extensions</td>\n<td>默认扩展名，在导入时省略扩展名时将按配置依次查找</td>\n<td>.gql/.graphql</td>\n</tr>\n<tr>\n<td>string</td>\n<td>指定导入模式，当为 true 时导入为字符串，而不是可执行的函数</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<p>注意，<code>gq-loader</code> 的 <code>extensions</code> 无论配置何值，在 <code>js</code> 中 <code>import</code> 时都不能省略扩展名，此选项仅作用于 <code>.gql</code> 文件 <code>import</code> 其它 <code>.gql</code> 文件</p>\n</div>",
    "title": "前端调用 GraphQL API，从未如此方便！",
    "last_reply_at": "2018-01-30T01:48:48.782Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 426,
    "create_at": "2018-01-28T18:58:30.526Z",
    "author": {
        "loginname": "houfeng",
        "avatar_url": "//gravatar.com/avatar/4ccd30a6ccc36203b826a50047183ea6?size=48"
    }
}, {
    "id": "56ef3edd532839c33a99d00e",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><a href=\"https://github.com/AutumnsWind/Front-end-tutorial\">资源教程原文</a></p>\n<ol>\n<li>\n<p>综合类</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/sb19871023/p/3894452.html\">前端知识体系</a></li>\n<li><a href=\"https://github.com/JacksonTian/fks\">前端知识结构</a></li>\n<li><a href=\"https://github.com/unruledboy/WebFrontEndStack\">Web前端开发大系概览</a></li>\n<li><a href=\"http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html\">Web前端开发大系概览-中文版</a></li>\n<li><a href=\"https://raw.githubusercontent.com/unruledboy/WebFrontEndStack/master/Web%20Front%20End%20Stack.png\">Web Front-end Stack v2.2</a></li>\n<li><a href=\"https://github.com/justjavac/free-programming-books-zh_CN\">免费的编程中文书籍索引</a></li>\n<li><a href=\"https://github.com/dypsilon/frontend-dev-bookmarks\">前端书籍</a></li>\n<li><a href=\"https://github.com/vhf/free-programming-books\">前端免费书籍大全</a></li>\n<li><a href=\"http://www.cnblogs.com/sb19871023/p/3894452.html\">前端知识体系</a></li>\n<li><a href=\"https://github.com/justjavac/free-programming-books-zh_CN\">免费的编程中文书籍索引</a></li>\n<li><a href=\"http://study.163.com/course/introduction/224014.htm\">智能社 - 精通JavaScript开发</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript\">重新介绍 JavaScript（JS 教程）</a></li>\n<li><a href=\"http://v.163.com/special/opencourse/bianchengdaolun.html\">麻省理工学院公开课：计算机科学及编程导论</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000002640298\">JavaScript中的this陷阱的最全收集–没有之一</a></li>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html\">JS函数式编程指南</a></li>\n<li><a href=\"http://liubin.github.io/promises-book/\">JavaScript Promise迷你书（中文版）</a></li>\n<li><a href=\"https://github.com/AlloyTeam/Mars\">腾讯移动Web前端知识库</a></li>\n<li><a href=\"https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide\">Front-End-Develop-Guide 前端开发指南</a></li>\n<li><a href=\"https://li-xinyang.gitbooks.io/frontend-notebook/content/\">前端开发笔记本</a></li>\n<li><a href=\"https://github.com/nieweidong/fetool\">大前端工具集 - 聂微东</a></li>\n<li><a href=\"https://dwqs.gitbooks.io/frontenddevhandbook/content/\">前端开发者手册</a></li>\n</ul>\n</li>\n<li>\n<p>入门类</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/jikey/p/3613082.html\">前端入门教程</a></li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\">瘳雪峰的Javascript教程</a></li>\n<li><a href=\"http://www.imooc.com/view/11\">jQuery基础教程</a></li>\n<li><a href=\"http://www.imooc.com/view/506\">前端工程师必备的PS技能——切图篇</a></li>\n<li><a href=\"https://github.com/qiu-deqing/FE-learning\">结合个人经历总结的前端入门方法</a></li>\n</ul>\n</li>\n<li>\n<p>效果类</p>\n<ul>\n<li><a href=\"http://www.imooc.com/learn/58\">弹出层</a></li>\n<li><a href=\"http://www.imooc.com/learn/18\">焦点图轮播特效</a></li>\n</ul>\n</li>\n<li>\n<p>工具类</p>\n<ul>\n<li><a href=\"http://www.imooc.com/learn/93\">css sprite 雪碧图制作</a></li>\n<li><a href=\"http://www.imooc.com/learn/390\">版本控制入门 – 搬进 Github</a></li>\n<li><a href=\"http://www.imooc.com/learn/30\">Grunt-beginner前端自动化工具</a></li>\n</ul>\n</li>\n<li>\n<p>慕课专题</p>\n<ul>\n<li><a href=\"http://www.imooc.com/space/teacher/id/197450\">张鑫旭 - 慕课系列</a></li>\n<li><a href=\"http://www.imooc.com/space/teacher/id/104593\">lyn - 慕课系列</a></li>\n<li><a href=\"http://www.imooc.com/space/teacher/id/290139\">艾伦 - 慕课系列</a></li>\n<li><a href=\"http://www.imooc.com/view/494\">碧仔 - Hello，移动WEB</a></li>\n</ul>\n</li>\n<li>\n<p>周报类</p>\n<ul>\n<li><a href=\"https://github.com/PaicHyperionDev/MobileDevWeekly\">平安科技移动开发二队技术周报</a></li>\n</ul>\n</li>\n</ol>\n<h3>六. API:</h3>\n<h4>1. 总目录</h4>\n<ol>\n<li>\n<p>开发中心</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\">mozilla js参考</a></li>\n<li><a href=\"https://developer.chrome.com/extensions/api_index.html\">chrome开发中心（chrome的内核已转向blink）</a></li>\n<li><a href=\"https://developer.apple.com/library/safari/navigation\">safari开发中心</a></li>\n<li><a href=\"https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94).aspx\">microsoft js参考</a></li>\n<li><a href=\"http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html\">js秘密花园</a></li>\n<li><a href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/\">js秘密花园</a></li>\n<li><a href=\"http://www.w3help.org/\">w3help</a> 综合Bug集合网站</li>\n</ul>\n</li>\n<li>\n<p>综合搜索</p>\n<ul>\n<li><a href=\"http://www.javascripting.com/\">javascripting</a></li>\n<li><a href=\"http://microjs.com/\">各种流行库搜索</a></li>\n</ul>\n</li>\n<li>\n<p>综合API</p>\n<ul>\n<li><a href=\"http://www.runoob.com/\">runoob.com-包含各种API集合</a></li>\n<li><a href=\"http://tool.oschina.net/apidocs\">开源中国在线API文档合集</a></li>\n<li><a href=\"http://devdocs.io/\">devdocs</a> 英文综合API网站</li>\n</ul>\n</li>\n</ol>\n<h4>2. jQuery</h4>\n<ul>\n<li><a href=\"http://www.jquery123.com/\">jQuery API 中文文档</a></li>\n<li><a href=\"http://hemin.cn/jq/\">hemin 在线版</a></li>\n<li><a href=\"http://www.css88.com/jqapi-1.9/on/\">css88 jq api</a></li>\n<li><a href=\"http://www.css88.com/jquery-ui-api/\">css88 jqui api</a></li>\n<li><a href=\"http://learn.jquery.com/\">学习jquery</a></li>\n<li><a href=\"http://james.padolsey.com/jquery/\">jquery 源码查找</a></li>\n</ul>\n<h4>3. Ecmascript</h4>\n<ul>\n<li><a href=\"https://leanpub.com/understandinges6/read\">Understanding ECMAScript 6 - Nicholas C. Zakas</a></li>\n<li><a href=\"https://leanpub.com/exploring-es6/read\">exploring-es6</a></li>\n<li><a href=\"https://github.com/es6-org/exploring-es6\">exploring-es6翻译</a></li>\n<li><a href=\"http://es6-org.github.io/exploring-es6/\">exploring-es6翻译后预览</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/\">阮一峰 es6</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/\">阮一峰 Javascript</a></li>\n<li><a href=\"http://yanhaijing.com/es5/\">ECMA-262，第 5 版</a></li>\n<li><a href=\"http://es5.github.io/\">es5</a></li>\n</ul>\n<h4>4. Js template</h4>\n<ul>\n<li><a href=\"http://garann.github.io/template-chooser/\">template-chooser</a></li>\n<li><a href=\"https://github.com/aui/artTemplate\">artTemplate</a></li>\n<li><a href=\"https://github.com/aui/tmodjs/blob/master/README.md\">tomdjs</a></li>\n<li><a href=\"http://juicer.name/docs/docs_zh_cn.html\">淘宝模板juicer模板</a></li>\n<li><a href=\"http://koen301.github.io/fxtpl/\">Fxtpl v1.0 繁星前端模板引擎</a></li>\n<li><a href=\"http://laytpl.layui.com/\">laytpl</a></li>\n<li><a href=\"https://github.com/mozilla/nunjucks\">mozilla - nunjucks</a></li>\n<li><a href=\"https://github.com/PaulGuo/Juicer\">Juicer</a></li>\n<li><a href=\"http://akdubya.github.io/dustjs/\">dustjs</a></li>\n<li><a href=\"http://ecomfe.github.io/etpl/\">etpl</a></li>\n</ul>\n<h4>5. 弹出层</h4>\n<ul>\n<li><a href=\"https://github.com/aui/artDialog\">artDialog 最新版</a></li>\n<li><a href=\"http://aui.github.io/artDialog/doc/index.html\">artDialog 文档</a></li>\n<li><a href=\"https://code.google.com/p/artdialog/downloads/list\">google code 下载地址</a></li>\n<li><a href=\"http://layer.layui.com/\">贤心弹出层</a></li>\n<li><a href=\"https://github.com/bh-lay/UI\">响应式用户交互组件库</a></li>\n<li><a href=\"http://t4t5.github.io/sweetalert/\">sweetalert-有css3动画弹出层</a></li>\n</ul>\n<h4>6. CSS</h4>\n<ul>\n<li><a href=\"http://tympanus.net/codrops/css_reference/\">CSS 语法参考</a></li>\n<li><a href=\"http://isux.tencent.com/css3/index.html\">CSS3动画手册</a></li>\n<li><a href=\"http://isux.tencent.com/css3/tools.html\">腾讯css3动画制作工具</a></li>\n<li><a href=\"http://linxz.github.io/tianyizone/\">志爷css小工具集合</a></li>\n<li><a href=\"http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb\">css3 js 移动大杂烩</a></li>\n<li><a href=\"http://bouncejs.com/\">bouncejs 触摸库</a></li>\n<li><a href=\"http://fian.my.id/Waves/\">css3 按钮动画</a></li>\n<li><a href=\"http://daneden.github.io/animate.css/\">animate.css</a></li>\n<li><a href=\"http://www.alloyteam.com/2015/10/8536/\">全局CSS的终结(狗带) [译]</a></li>\n</ul>\n<h4>7. Angularjs</h4>\n<ul>\n<li><a href=\"https://github.com/dolymood/AngularLearning\">Angular.js 的一些学习资源</a></li>\n<li><a href=\"http://angularjs.cn/\">angularjs中文社区</a></li>\n<li><a href=\"http://www.cnblogs.com/xuwenmin888/p/3739096.html\">Angularjs源码学习</a></li>\n<li><a href=\"http://www.ifeenan.com/?c=AngularJS\">Angularjs源码学习</a></li>\n<li><a href=\"http://angular-ui.github.io/bootstrap/\">angular对bootstrap的封装</a></li>\n<li><a href=\"https://cnodejs.org/topic/51404e0f069911196d2e3923\">angularjs + nodejs</a></li>\n<li><a href=\"http://www.cnblogs.com/lvdabao/tag/AngularJs/\">吕大豹 Angularjs</a></li>\n<li><a href=\"http://www.infoq.com/cn/news/2013/02/angular-web-app\">AngularJS 最佳实践</a></li>\n<li><a href=\"http://www.lovelucy.info/angularjs-best-practices.html\">Angular的一些扩展指令</a></li>\n<li><a href=\"https://github.com/Pasvaz/bindonce\">Angular数据绑定原理</a></li>\n<li><a href=\"https://github.com/angular-ui/\">一些扩展Angular UI组件</a></li>\n<li><a href=\"http://voidcanvas.com/emberjs-vs-angularjs-performance-testing/\">Ember和AngularJS的性能测试</a></li>\n<li><a href=\"http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html\">带你走近AngularJS - 基本功能介绍</a></li>\n<li><a href=\"http://angular.duapp.com/docs/guide\">Angularjs开发指南</a></li>\n<li><a href=\"http://www.cnblogs.com/amosli/p/3710648.html\">Angularjs学习</a></li>\n<li><a href=\"http://www.rainweb.cn/article/angularjs-jquery.html\">不要带着jQuery的思维去学习AngularJS</a></li>\n<li><a href=\"http://wangjiatao.diandian.com/?tag=angularjs\">angularjs 学习笔记</a></li>\n<li><a href=\"http://www.angularjs.cn/T008\">angularjs 开发指南</a></li>\n<li><a href=\"https://github.com/jmcunningham/AngularJS-Learning\">angularjs 英文资料</a></li>\n<li><a href=\"http://angular-ui.github.io/bootstrap/\">angular bootstrap</a></li>\n<li><a href=\"https://github.com/opitzconsulting/jquery-mobile-angular-adapter\">angular jq mobile</a></li>\n<li><a href=\"http://mgcrea.github.io/angular-strap/\">angular ui</a></li>\n<li><a href=\"http://www.tuicool.com/articles/7ZZVr2\">整合jQuery Mobile+AngularJS经验谈</a></li>\n<li><a href=\"http://blog.jobbole.com/46589/\">有jQuery背景，该如何用AngularJS编程思想</a></li>\n<li><a href=\"http://each.sinaapp.com/angular/\">AngularJS在线教程</a></li>\n<li><a href=\"http://www.zouyesheng.com/angular.html\">angular学习笔记</a></li>\n</ul>\n<h4>8. React</h4>\n<ul>\n<li><a href=\"http://www.react-china.org/\">react.js 中文论坛</a></li>\n<li><a href=\"https://facebook.github.io/react/index.html\">react.js 官方网址</a></li>\n<li><a href=\"https://facebook.github.io/react/docs/getting-started.html\">react.js 官方文档</a></li>\n<li><a href=\"http://material-ui.com/#/\">react.js material UI</a></li>\n<li><a href=\"http://touchstonejs.io/\">react.js TouchstoneJS UI</a></li>\n<li><a href=\"http://amazeui.org/react/\">react.js amazeui UI</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/03/react.html\">React 入门实例教程 - 阮一峰</a></li>\n<li><a href=\"http://wiki.jikexueyuan.com/project/react-native/\">React Native 中文版</a></li>\n<li><a href=\"http://www.html-js.com/article/Fakefish%203053\">Webpack 和 React 小书 - 前端乱炖</a></li>\n<li><a href=\"https://fakefish.github.io/react-webpack-cookbook/\">Webpack 和 React 小书 - gitbook</a></li>\n<li><a href=\"https://github.com/webpack/webpack\">webpack</a></li>\n<li><a href=\"http://html-js.com/article/3009\">Webpack，101入门体验</a></li>\n<li><a href=\"http://html-js.com/article/3113\">webpack入门教程</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000003499526\">基于webpack搭建前端工程解决方案探索</a></li>\n<li><a href=\"http://www.piliyu.com/\">React原创实战视频教程</a></li>\n</ul>\n<h4>9. 移动端API</h4>\n<ol>\n<li>API\n<ul>\n<li><a href=\"https://github.com/jtyjty99999/mobileTech\">99移动端知识集合</a></li>\n<li><a href=\"https://github.com/AlloyTeam/Mars\">移动端前端开发知识库</a></li>\n<li><a href=\"http://caibaojian.com/mobile-web-bug.html\">移动前端的一些坑和解决方法（外观表现）</a></li>\n<li><a href=\"http://www.cnblogs.com/PeunZhang/p/3407453.html\">【原】移动web资源整理</a></li>\n<li><a href=\"http://mweb.baidu.com/zeptoapi/\">zepto 1.0 中文手册</a></li>\n<li><a href=\"http://www.html-5.cn/Manual/Zepto/\">zepto 1.0 中文手册</a></li>\n<li><a href=\"http://www.css88.com/doc/zeptojs_api/\">zepto 1.1.2</a></li>\n<li><a href=\"http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html\">zepto 中文注释</a></li>\n<li><a href=\"http://app-framework-software.intel.com/api.php\">jqmobile 手册</a></li>\n<li><a href=\"https://github.com/maxzhang/maxzhang.github.com/issues\">移动浏览器开发集合</a></li>\n<li><a href=\"https://github.com/hoosin/mobile-web-favorites\">移动开发大杂烩</a></li>\n<li><a href=\"http://lin-chao.github.io/2014/11/14/%E5%BE%AE%E4%BF%A1webview%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/\">微信webview中的一些问题</a></li>\n</ul>\n</li>\n<li>框架\n<ul>\n<li><a href=\"http://framework7.taobao.org/\">特色的HTML框架可以创建精美的iOS应用</a></li>\n<li><a href=\"http://m.sui.taobao.org/\">淘宝SUI</a></li>\n</ul>\n</li>\n</ol>\n<h4>10. avalon</h4>\n<ul>\n<li><a href=\"http://avalonjs.github.io/\">avalonjs</a></li>\n<li><a href=\"http://ued.qunar.com/oniui/index.html\">Avalon新一代UI库： OniUI</a></li>\n<li><a href=\"https://github.com/RubyLouvre/avalon.oniui\">avalon.oniui-基于avalon的组件库</a></li>\n<li><a href></a></li>\n</ul>\n<h4>11. Requriejs</h4>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/10/javascript_module.html\">Javascript模块化编程（一）：模块的写法 </a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html\">Javascript模块化编程（二）：AMD规范</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2012/11/require_js.html\">Javascript模块化编程（三）：require.js的用法</a></li>\n<li><a href=\"http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html\">RequireJS入门（一）</a></li>\n<li><a href=\"http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html\">RequireJS入门（二）</a></li>\n<li><a href=\"http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html\">RequireJS进阶（三）</a></li>\n<li><a href=\"http://www.cnblogs.com/yexiaochai/p/3632580.html\">requrie源码学习</a></li>\n<li><a href=\"http://www.oschina.net/translate/getting-started-with-the-requirejs-library\">requrie 入门指南</a></li>\n<li><a href=\"http://www.cnblogs.com/yexiaochai/p/3214926.html\">requrieJS 学习笔记</a></li>\n<li><a href=\"http://cyj.me/why-seajs/requirejs/\">requriejs 其一 </a></li>\n<li><a href=\"http://www.cnblogs.com/yexiaochai/p/3221081.html\">require backbone结合</a></li>\n</ul>\n<h4>12. Seajs</h4>\n<ul>\n<li><a href=\"http://seajs.org/\">seajs</a></li>\n<li><a href=\"http://cyj.me/why-seajs/zh/\">seajs 中文手册</a></li>\n</ul>\n<h4>13. Less,sass</h4>\n<ul>\n<li><a href=\"http://www.w3cplus.com/sassguide/\">sass</a></li>\n<li><a href=\"http://www.sass.hk/\">sass教程-sass中国</a></li>\n<li><a href=\"http://sass.bootcss.com/\">Sass 中文文档</a></li>\n<li><a href=\"http://less.bootcss.com/\">less</a></li>\n</ul>\n<h4>14. Markdown</h4>\n<ul>\n<li><a href=\"http://wowubuntu.com/markdown/\">Markdown 语法说明 (简体中文版)</a></li>\n<li><a href=\"https://github.com/LearnShare/Learning-Markdown/blob/master/README.md\">markdown入门参考</a></li>\n<li><a href=\"https://www.gitbook.com/\">gitbook</a> 国外的在线markdown可编辑成书</li>\n<li><a href=\"https://www.zybuluo.com/mdeditor\">mdeditor</a>  一款国内的在线markdown编辑器</li>\n<li><a href=\"https://stackedit.io\">stackedit</a> 国外的在线markdown编辑器，功能强大，同步云盘</li>\n<li><a href=\"http://bh-lay.github.io/mditor/\">mditor</a> 一款轻量级的markdown编辑器</li>\n<li><a href=\"https://github.com/lepture/editor\">lepture-editor</a></li>\n<li><a href=\"https://github.com/jbt/markdown-editor\">markdown-editor</a></li>\n</ul>\n<h4>15. D3</h4>\n<ul>\n<li><a href=\"https://github.com/mbostock/d3/wiki/Tutorials\">d3 Tutorials</a></li>\n<li><a href=\"https://github.com/mbostock/d3/wiki/Gallery\">Gallery</a></li>\n<li><a href=\"http://datavisual.lofter.com/post/40cf3a_188e535\">lofter</a></li>\n<li><a href=\"http://alanland.iteye.com/blog/1878595\">iteye</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/library/d3.html\">ruanyifeng</a></li>\n</ul>\n<h4>16. 兼容性</h4>\n<ul>\n<li><a href=\"http://kangax.github.io/compat-table/es6/\">esma 兼容列表</a></li>\n<li><a href=\"http://jigsaw.w3.org/css-validator/validator.html.zh-cn\">W3C CSS验证服务</a></li>\n<li><a href=\"http://caniuse.com/#index\">caniuse</a></li>\n<li><a href=\"http://csscreator.com/properties\">csscreator</a></li>\n<li><a href=\"https://msdn.microsoft.com/zh-cn/library/cc351024(v=vs.85).aspx\">microsoft</a></li>\n<li><a href=\"http://www.responsinator.com/\">在线测兼容-移动端</a></li>\n<li><a href=\"https://www.manymo.com/emulators\">emulators</a></li>\n</ul>\n<h4>17. UI相关</h4>\n<ul>\n<li><a href=\"http://v3.bootcss.com/\">bootcss</a></li>\n<li><a href=\"http://www.w3cplus.com/MetroUICSS/\">MetroUICSS</a></li>\n<li><a href=\"http://semantic-ui.com/\">semantic</a></li>\n<li><a href=\"http://alexwolfe.github.io/Buttons/\">Buttons</a></li>\n<li><a href=\"http://hiloki.github.io/kitecss/\">kitecss</a></li>\n<li><a href=\"http://www.pintuer.com/\">pintuer</a></li>\n<li><a href=\"http://amazeui.org/\">amazeui</a></li>\n<li><a href=\"http://www.worldhello.net/gotgithub/index.html\">worldhello</a></li>\n<li><a href=\"http://igit.linuxtoy.org/contents.html\">linuxtoy</a></li>\n<li><a href=\"http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/\">gitmagic</a></li>\n<li><a href=\"http://rogerdudler.github.io/git-guide/index.zh.html\">rogerdudler</a></li>\n<li><a href=\"http://gitref.justjavac.com/\">gitref</a></li>\n<li><a href=\"http://git-scm.com/book/zh\">book</a></li>\n<li><a href=\"http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic/\">gogojimmy</a></li>\n</ul>\n<h4>18. HTTP</h4>\n<ul>\n<li><a href=\"http://segmentfault.com/bookmark/1230000002521721\">HTTP API 设计指南</a></li>\n</ul>\n<h4>19. 其它API</h4>\n<ul>\n<li><a href>javascript流行库汇总</a></li>\n<li><a href=\"http://niceue.com/validator/demo/index.php\">验证api</a></li>\n<li><a href=\"http://www.css88.com/doc/underscore/\">underscore 中文手册</a></li>\n<li><a href=\"http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031\">underscore源码分析</a></li>\n<li><a href=\"http://yalishizhude.github.io/tags/underscore/\">underscore源码分析-亚里士朱德的博客</a></li>\n<li><a href=\"http://underscorejs.org/\">underscrejs en api</a></li>\n<li><a href=\"https://lodash.com/\">lodash - underscore的代替品</a></li>\n<li><a href=\"http://extjs-doc-cn.github.io/ext4api/\">ext4api</a></li>\n<li><a href=\"http://www.csser.com/tools/backbone/backbone.js.html\">backbone 中文手册</a></li>\n<li><a href=\"http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm\">qwrap手册</a></li>\n<li><a href=\"http://easings.net/zh-cn\">缓动函数</a></li>\n<li><a href=\"http://www.w3school.com.cn/svg/svg_reference.asp\">svg 中文参考</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\">svg mdn参考</a></li>\n<li><a href=\"https://github.com/gabelerner/canvg\">svg 导出 canvas</a></li>\n<li><a href=\"https://github.com/exupero/saveSvgAsPng\">svg 导出 png</a></li>\n<li><a href=\"http://www.zamzar.com/convert/ai-to-svg/\">ai-to-svg</a></li>\n<li><a href=\"https://github.com/machao/localStorage\">localStorage 库</a></li>\n</ul>\n<h4>20. 图表类</h4>\n<ul>\n<li><a href=\"http://www.hcharts.cn/api/index.php\">Highcharts 中文API</a></li>\n<li><a href=\"http://api.highcharts.com/highcharts\">Highcharts 英文API</a></li>\n<li><a href=\"http://echarts.baidu.com/\">ECharts 百度的图表软件</a></li>\n<li><a href=\"http://lbs.amap.com/api/\">高德地图</a></li>\n<li><a href=\"http://paperjs.org/\">开源的矢量图脚本框架</a></li>\n<li><a href=\"http://jvectormap.com/\">svg 地图</a></li>\n</ul>\n<h4>21. vue</h4>\n<ul>\n<li><a href=\"http://cn.vuejs.org/\">Vue</a></li>\n<li><a href=\"http://forum.vuejs.org/\">Vue 论坛</a></li>\n<li><a href=\"http://www.cnblogs.com/aaronjs/p/3660102.html\">Vue 入门指南</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000411057\">Vue 的一些资源索引</a></li>\n<li><a href></a></li>\n</ul>\n<h4>21. 正则</h4>\n<ul>\n<li><a href=\"http://segmentfault.com/a/1190000002471140\">JS正则表达式元字符</a></li>\n<li><a href=\"http://deerchao.net/tutorials/regex/regex.htm\">正则表达式30分钟入门教程</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">MDN-正则表达式</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/stdlib/regexp.html\">ruanyifeng - RegExp对象</a></li>\n<li><a href=\"http://div.io/topic/764?page=1\">小胡子哥 - 进阶正则表达式</a></li>\n<li><a href=\"https://github.com/Cedriking/is.js/blob/master/is.js\">is.js</a></li>\n<li><a href=\"http://regexper.com/\">正则在线测试</a></li>\n<li><a href></a></li>\n</ul>\n<h4>22. ionic</h4>\n<ul>\n<li><a href=\"https://github.com/ychow/ionic-guide\">ionic</a></li>\n</ul>\n<h4>23. 其它</h4>\n<ul>\n<li><a href=\"http://mockjs.com/\">Mock.js 是一款模拟数据生成器</a></li>\n</ul>\n<h3>七. 开发规范</h3>\n<ol>\n<li>\n<p>前端</p>\n<ul>\n<li><a href=\"http://alloyteam.github.io/CodeGuide\">通过分析github代码库总结出来的工程师代码书写习惯</a></li>\n<li><a href=\"http://codeguide.bootcss.com/\">HTML&amp;CSS编码规范 by @mdo</a></li>\n<li><a href=\"http://www.alloyteam.com/2011/10/107/\">团队合作的css命名规范-腾讯AlloyTeam前端团队</a></li>\n<li><a href=\"http://yuwenhui.github.io/\">前端编码规范之js - by yuwenhui</a></li>\n<li><a href=\"http://www.cnblogs.com/hustskyking/p/javascript-spec.html\">前端编码规范之js - by 李靖</a></li>\n<li><a href=\"http://zhibimo.com/read/Ashu/front-end-style-guide/\">前端开发规范手册</a></li>\n<li><a href=\"https://github.com/yuche/javascript#table-of-contents\">Airbnb JavaScript 编码规范（简体中文版）</a></li>\n<li><a href=\"http://www.zhihu.com/question/20351507\">AMD与CMD规范的区别</a></li>\n<li><a href=\"http://www.cnblogs.com/tugenhua0707/p/3507957.html\">AMD与CMD规范的区别</a></li>\n<li><a href=\"http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html\">KISSY 源码规范</a></li>\n<li><a href=\"http://codeguide.bootcss.com/\">bt编码规范</a></li>\n<li><a href=\"https://github.com/Suxiaogang/Code_Guide\">规范加强版</a></li>\n<li><a href=\"http://blog.jobbole.com/79075/\">前端代码规范 及 最佳实践</a></li>\n<li><a href=\"http://coderlmn.github.io/code-standards/\">百度前端规范</a></li>\n<li><a href=\"http://isobar-idev.github.io/code-standards/\">百度前端规范</a></li>\n<li><a href=\"http://zhuanlan.zhihu.com/fuyun/19884834\">百度前端规范</a></li>\n<li><a href=\"https://github.com/gf-rd/es6-coding-style\">ECMAScript6 编码规范–广发证券前端团队</a></li>\n<li><a href=\"http://blog.jobbole.com/79484/\">JavaScript 风格指南/编码规范（Airbnb公司版）</a></li>\n<li><a href=\"http://nec.netease.com/standard\">网易前端开发规范</a></li>\n<li><a href=\"http://www.75team.com/archives/1049\">css模块</a></li>\n<li><a href=\"https://github.com/ecomfe/spec\">前端规范资源列表</a></li>\n</ul>\n</li>\n<li>\n<p>PHP</p>\n<ul>\n<li><a href=\"http://segmentfault.com/a/1190000000443795\">最流行的PHP 代码规范</a></li>\n<li><a href=\"https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md\">最流行的PHP 代码规范</a></li>\n</ul>\n</li>\n<li>\n<p>Android</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/lcw/p/3619181.html\">【敏捷开发】Android团队开发规范</a></li>\n<li><a href=\"http://www.jianshu.com/p/4390f4fe19b3\">Android 开发规范与应用</a></li>\n</ul>\n</li>\n</ol>\n<h3>八. 其它收集</h3>\n<h4>1. 各大公司开源项目</h4>\n<ul>\n<li><a href=\"https://code.facebook.com/projects/web/\">Facebook Projects</a></li>\n<li><a href=\"http://fex.baidu.com/\">百度web前端研发部</a></li>\n<li><a href=\"http://efe.baidu.com/\">百度EFE</a></li>\n<li><a href=\"https://github.com/fex-team/\">百度github</a></li>\n<li><a href=\"http://www.alloyteam.com/\">alloyteam</a></li>\n<li><a href=\"http://alloyteam.github.io/\">alloyteam-github</a></li>\n<li><a href=\"https://github.com/AlloyTeam/AlloyGameEngine\">alloyteam-AlloyGameEngine</a></li>\n<li><a href=\"http://alloyteam.github.io/AlloyDesigner/\">AlloyDesigner</a> 即时修改，即时保存，设计稿较正，其它开发辅助工具</li>\n<li><a href=\"http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shao/\">H5交互页编辑器AEditor介绍</a> H5动画交互页开发的工具介绍</li>\n<li><a href=\"http://aeditor.alloyteam.com/\">AEditor</a> H5动画交互页开发的工具</li>\n<li><a href=\"http://forum.maka.im/wordpress/\">maka</a></li>\n<li><a href=\"https://github.com/fenbility/weekly-feed\">值得订阅的weekly</a></li>\n<li><a href=\"http://cube.qq.com/\">腾讯html5</a></li>\n<li><a href=\"http://75team.github.io/\">奇舞团开源项目</a></li>\n<li><a href=\"http://ued.qunar.com/\">Qunar UED</a></li>\n</ul>\n<h4>2. Javascript</h4>\n<ol>\n<li>\n<p>常用</p>\n<ul>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome/\">ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性</a></li>\n<li><a href=\"http://mottie.github.io/Keyboard/\">模拟键盘</a></li>\n<li><a href=\"https://github.com/hotoo/pinyin\">拼音</a></li>\n<li><a href=\"https://github.com/mc-zone/IDValidator\">中国个人身份证号验证</a></li>\n</ul>\n</li>\n<li>\n<p>算法</p>\n<ul>\n<li><a href=\"https://github.com/Ralph-Wang/algorithm.in.js\">数据结构与算法 JavaScript 描述. 章节练习</a></li>\n<li><a href=\"https://github.com/twobin/twobinSort\">常见排序算法（JS版）</a></li>\n<li><a href=\"https://github.com/luofei2011/jsAgm/blob/master/js/sort.js\">经典排序</a></li>\n<li><a href=\"https://github.com/hechangmin/jssort\">常见排序算法-js版本</a></li>\n<li><a href=\"https://github.com/lightningtgc/JavaScript-Algorithms\">JavaScript 算法与数据结构 精华集</a></li>\n<li><a href=\"http://www.nowcoder.com/live/courses\">面试常考算法题精讲</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>移动端</p>\n<ul>\n<li><a href=\"https://github.com/ftlabs/fastclick\">fastclick</a></li>\n<li><a href=\"https://github.com/mmastrac/jquery-noclickdelay\">no-click-delay</a></li>\n</ul>\n</li>\n<li>\n<p>JSON</p>\n<ul>\n<li><a href=\"http://beta.json-generator.com/\">模拟生成JSON数据</a></li>\n<li><a href=\"http://jsonp.afeld.me/\">返回跨域JSONAPI</a></li>\n</ul>\n</li>\n</ol>\n<h4>3. Html5</h4>\n<ul>\n<li><a href=\"http://www.zhihu.com/question/24398907\">HTML5 有哪些让你惊艳的 demo？</a></li>\n</ul>\n<h4>4. CSS</h4>\n<ul>\n<li><a href=\"http://browserhacks.com/\">browserhacks</a></li>\n<li><a href></a></li>\n</ul>\n<h4>5. jQuery</h4>\n<ol>\n<li>\n<p>焦点图</p>\n<ul>\n<li><a href=\"https://github.com/koen301/myfocus\">myfocus</a></li>\n<li><a href=\"http://www.chhua.com/myfocus/\">myfocus-官方演示站</a></li>\n<li><a href=\"http://www.superslide2.com/\">SuperSlidev2.1 – 大话主席</a></li>\n<li><a href=\"http://www.bujichong.com/sojs/soChange/index.html\">soChange</a></li>\n</ul>\n</li>\n</ol>\n<h4>6. Ext, EasyUI, J-UI 及其它各种UI方案</h4>\n<ol>\n<li>\n<p>Ext</p>\n<ul>\n<li><a href=\"https://www.sencha.com/products/extjs/\">extjs</a></li>\n<li><a href=\"http://docs.sencha.com/extjs/4.0.7/\">ext4英文api</a></li>\n<li><a href=\"http://extjs-doc-cn.github.io/ext4api/\">ext4中文api</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>EasyUI</p>\n<ul>\n<li><a href=\"http://jquery-easyui.googlecode.com/svn/trunk/src/\">jquery easyui 未压缩源代码</a></li>\n</ul>\n</li>\n<li>\n<p>J-UI</p>\n<ul>\n<li><a href=\"http://jui.org/\">J-UI</a></li>\n</ul>\n</li>\n<li>\n<p>Other</p>\n<ul>\n<li><a href=\"http://dcloudio.github.io/mui/\">MUI-最接近原生APP体验的高性能前端框架</a></li>\n<li><a href=\"http://amazeui.org/\">Amaze UI | 中国首个开源 HTML5 跨屏前端框架</a></li>\n<li><a href=\"http://m.sui.taobao.org/\">淘宝 HTML5 前端框架</a></li>\n<li><a href=\"http://docs.kissyui.com/\">KISSY - 阿里前端JavaScript库</a></li>\n<li><a href=\"http://nej.netease.com/\">网易Nej - Nice Easy Javascript</a></li>\n<li><a href=\"http://demos.telerik.com/kendo-ui/mvvm/index\">Kendo UI MVVM Demo</a></li>\n<li><a href=\"http://www.bootcss.com/\">Bootstrap</a></li>\n<li><a href=\"http://smartui.chinamzz.com/\">Smart UI</a></li>\n<li><a href=\"http://developer.yahoo.com/yui/grids/\">雅虎UI - CSS UI</a></li>\n</ul>\n</li>\n</ol>\n<h4>7. 页面 社会化 分享功能</h4>\n<ul>\n<li><a href=\"http://share.baidu.com/\">百度分享</a> pc端</li>\n<li><a href=\"http://jiathis.com/\">JiaThis</a> pc端</li>\n<li><a href=\"http://developer.baidu.com/soc/share\">社会化分享组件</a> 移动端</li>\n<li><a href=\"http://www.mob.com/#/index\">ShareSDK 轻松实现社会化功能</a> 移动端</li>\n<li><a href=\"http://dev.umeng.com/social/android/quick-integration\">友盟分享</a> 移动端</li>\n</ul>\n<h4>8. 富文本编辑器</h4>\n<ul>\n<li><a href=\"http://ueditor.baidu.com/website/\">百度 ueditor</a></li>\n<li><a href=\"http://ckeditor.com/\">经典的ckeditor</a></li>\n<li><a href=\"http://kindeditor.net/\">经典的kindeditor</a></li>\n<li><a href=\"http://www.bootcss.com/p/bootstrap-wysiwyg/\">wysiwyg</a></li>\n<li><a href=\"http://integ.github.io/BachEditor/\">一个有情怀的编辑器。Bach’s Editor</a></li>\n<li><a href=\"https://github.com/mycolorway/simditor\">tower用的编辑器</a></li>\n<li><a href=\"https://github.com/summernote/summernote\">summernote 编辑器</a></li>\n<li><a href=\"http://neilj.github.io/Squire/\">html5编辑器</a></li>\n<li><a href=\"http://lab.hustlzp.com/XEditor/\">XEditor</a></li>\n<li><a href=\"https://github.com/wangfupeng1988/wangEditor\">wangEditor</a></li>\n</ul>\n<h4>9. 日历</h4>\n<ol>\n<li>\n<p>PC</p>\n<ul>\n<li><a href=\"http://www.my97.net/dp/demo/index.htm\">经典my97</a></li>\n<li><a href=\"http://www.cnblogs.com/gbin1/archive/2012/04/16/2452105.html\">强大的独立日期选择器</a></li>\n<li><a href=\"http://fullcalendar.io/\">fullcalendar</a></li>\n<li><a href=\"http://blog.csdn.net/francislaw/article/details/7740630\">fullcalendar日历控件知识点集合 </a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_9475b1c101012c5f.html\">中文api</a></li>\n<li><a href=\"https://github.com/zzyss86/LunarCalendar\">农历日历</a></li>\n<li><a href=\"http://www.sucaisj.com/jiaoben/date/201509/16856.html\">超酷的仿百度带节日日历老黄历控件</a></li>\n<li><a href=\"http://momentjs.com/\">日期格式化</a></li>\n<li><a href=\"https://github.com/Johnqing/QPAYCalendar/\">大牛日历控件</a></li>\n<li><a href=\"https://github.com/Iamlars/dateMarker\">我群某管理作品</a></li>\n<li><a href=\"http://digitalbush.com/projects/masked-input-plugin/\">input按位替换-官网</a></li>\n<li><a href=\"https://github.com/digitalBush/jquery.maskedinput/tree/1.2.2\">input按位替换-github</a></li>\n<li><a href=\"https://github.com/dangrossman/bootstrap-daterangepicker\">bootstrap-daterangepicker</a></li>\n<li><a href=\"http://www.vandelaydesign.com/30-best-free-jquery-plugins/\">国外30个插件集合</a></li>\n<li><a href=\"http://dbushell.com/2012/10/09/pikaday-javascript-datepicker/\">JavaScript datepicker</a></li>\n<li><a href=\"http://jonthornton.github.io/Datepair.js/\">Datepair.js</a></li>\n<li><a href=\"https://github.com/glad/glDatePicker\">一个风格多样的日历</a></li>\n<li><a href=\"http://amsul.ca/pickadate.js/date/\">弹出层式的全日历</a></li>\n<li><a href=\"http://www.daterangepicker.com/\">jquery双日历</a></li>\n</ul>\n</li>\n<li>\n<p>移动</p>\n<ul>\n<li><a href=\"http://www.frankdemo.cn/index.php?c=content&amp;a=show&amp;id=115\">大气实用jQuery手机移动端日历日期选择插件</a></li>\n<li><a href=\"https://mobiscroll.com/\">jQuery Mobile 移动开发中的日期插件Mobiscroll </a></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li>\n<p>Date library</p>\n<ul>\n<li><a href=\"https://github.com/datejs/Datejs\">Datejs</a></li>\n<li><a href=\"http://sugarjs.com/api/Date\">sugarjs</a></li>\n</ul>\n</li>\n</ol>\n<h4>10. 综合效果搜索平台</h4>\n<ul>\n<li><a href=\"http://www.jq22.com\">效果网</a></li>\n<li><a href=\"http://www.17sucai.com/\">17素材</a></li>\n<li><a href=\"http://microjs.com/\">常用的JavaScript代码片段</a></li>\n</ul>\n<h4>11. 前端工程化</h4>\n<ol>\n<li>\n<p>概述</p>\n<ul>\n<li><a href=\"http://www.awesomes.cn/\">前端工具大全</a></li>\n<li><a href=\"https://github.com/fouber/blog/issues/10?from=timeline&amp;isappinstalled=0#\">什么是前端工程化</a></li>\n</ul>\n</li>\n<li>\n<p>Gulp</p>\n<ul>\n<li><a href=\"http://gulpjs.com/\">Gulp官网</a></li>\n<li><a href=\"http://www.gulpjs.com.cn/\">Gulp中文网</a></li>\n<li><a href=\"https://github.com/Platform-CUF/use-gulp\">gulp资料收集</a></li>\n<li><a href=\"http://javascript.ruanyifeng.com/tool/gulp.html\">Gulp：任务自动管理工具 - ruanyifeng</a></li>\n<li><a href=\"http://gulpjs.com/plugins/\">Gulp插件</a></li>\n<li><a href=\"http://www.ido321.com/1622.html\">Gulp不完全入门教程</a></li>\n<li><a href=\"https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33\">为什么使用gulp?</a></li>\n<li><a href=\"http://www.dbpoo.com/getting-started-with-gulp/\">Gulp安装及配合组件构建前端开发一体化</a></li>\n<li><a href=\"https://github.com/nimojs/gulp-book\">Gulp 入门指南</a></li>\n<li><a href=\"https://github.com/nimojs/blog/issues/19\">Gulp 入门指南 - nimojs</a></li>\n<li><a href=\"http://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/\">Gulp入门教程</a></li>\n<li><a href=\"http://www.imooc.com/video/5692\">Gulp in Action</a></li>\n<li><a href=\"http://www.w3ctech.com/topic/134\">Gulp开发教程（翻译）</a></li>\n<li><a href=\"http://www.cnblogs.com/2050/p/4198792.html\">前端构建工具gulpjs的使用介绍及技巧</a></li>\n</ul>\n</li>\n<li>\n<p>Grunt</p>\n<ul>\n<li><a href=\"http://gruntjs.com/\">gruntjs</a></li>\n<li><a href=\"http://www.gruntjs.net/\">Grunt中文网</a></li>\n</ul>\n</li>\n<li>\n<p>Fis</p>\n<ul>\n<li><a href=\"http://fex-team.github.io/fis-site/index.html\">fis 官网</a></li>\n<li><a href=\"http://fis.baidu.com/\">fis</a></li>\n</ul>\n</li>\n</ol>\n<h4>12. 轮播图</h4>\n<ol>\n<li>\n<p>pc图轮</p>\n<ul>\n<li><a href=\"http://www.jsfoot.com/jquery/demo/2011-09-20/192.html\">单屏轮播sochange</a></li>\n<li><a href=\"http://bxslider.com/examples/carousel-demystified\">左右按钮多图切换</a></li>\n<li><a href=\"https://github.com/alvarotrigo/fullPage.js/\">fullpage全屏轮播</a></li>\n</ul>\n</li>\n<li>\n<p>移动端</p>\n<ul>\n<li><a href=\"http://www.swipejs.com/\">无缝切换</a></li>\n<li><a href=\"http://www.idangero.us/swiper/\">滑屏效果</a></li>\n<li><a href=\"https://github.com/peunzhang/fullpage\">全屏fullpage</a></li>\n<li><a href=\"https://github.com/qiqiboy/touchslider\">单个图片切换</a></li>\n<li><a href=\"https://github.com/peunzhang/slip.js\">单个全屏切换</a></li>\n<li><a href=\"http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group\">百度的切换库</a></li>\n<li><a href=\"https://github.com/peunzhang/iSlider\">单个全屏切换</a></li>\n<li><a href=\"https://github.com/saw/touch-interfaces\">滑屏效果</a></li>\n<li><a href=\"http://baijs.com/tinycircleslider/\">旋转拖动设置</a></li>\n<li><a href=\"http://touchslider.com/\">类似于swipe切换</a></li>\n<li><a href=\"http://www.swiper.com.cn/demo/index.html\">支持多种形式的触摸滑动</a></li>\n<li><a href=\"https://github.com/joker-ye/main/blob/master/wap/index.html\">滑屏效果</a></li>\n<li><a href=\"http://www.superslide2.com/\">大话主席pc移动图片轮换</a></li>\n<li><a href=\"https://github.com/hahnzhu/parallax.js\">滑屏效果</a></li>\n<li><a href=\"https://github.com/yanhaijing/zepto.fullpage\">基于zepto的fullpage</a></li>\n<li><a href=\"http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html\">[WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应</a></li>\n<li><a href=\"http://loo2k.com/blog/detecting-wechat-client/\">判断微信客户端的那些坑</a></li>\n<li><a href=\"https://github.com/JefferyWang/nativeShare.js\">可以通过javascript直接调用原生分享的工具</a></li>\n<li><a href=\"http://www.jiathis.com/help/html/weixin-share-code\">JiaThis 分享到微信代码</a></li>\n<li><a href=\"http://fex.baidu.com/blog/2015/05/cross-mobile/\">聊聊移动端跨平台开发的各种技术</a></li>\n<li><a href=\"http://www.zhihu.com/question/29922082\">前端自动化测试</a></li>\n<li><a href=\"http://ajccom.github.io/niceslider/\">多种轮换图片</a></li>\n<li><a href=\"https://mango.github.io/slideout/\">滑动侧边栏</a></li>\n</ul>\n</li>\n</ol>\n<h4>13. 文件上传</h4>\n<ul>\n<li><a href=\"http://fex.baidu.com/webuploader/\">百度上传组件</a></li>\n<li><a href=\"https://blueimp.github.io/jQuery-File-Upload/\">上传</a></li>\n<li><a href=\"http://www.hdfu.net/\">flash 头像上传</a></li>\n<li><a href=\"http://www.dropzonejs.com/\">图片上传预览</a></li>\n<li><a href=\"http://elemefe.github.io/image-cropper/\">图片裁剪</a></li>\n<li><a href=\"http://www.shearphoto.com/\">图片裁剪-shearphoto</a></li>\n<li><a href=\"http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&amp;os=0&amp;sort=view&amp;p=2\">jQuery图片处理</a></li>\n<li><a href></a></li>\n</ul>\n<h4>14. 模拟select</h4>\n<ul>\n<li><a href=\"http://aui.github.io/popupjs/doc/selectbox.html\">糖饼 select</a></li>\n<li><a href=\"https://github.com/rmm5t/jquery-flexselect\">flexselect</a></li>\n<li><a href=\"http://loudev.com/\">双select</a></li>\n<li><a href=\"http://select2.github.io/\">select2</a></li>\n<li><a href></a></li>\n</ul>\n<h4>15. 取色插件</h4>\n<ul>\n<li><a href=\"http://www.jq22.com/plugin/367\">类似 Photoshop 的界面取色插件</a></li>\n<li><a href=\"https://github.com/jquery/jquery-color/\">jquery color</a></li>\n<li><a href=\"http://www.oschina.net/project/tag/287/color-picker\">取色插件集合</a></li>\n<li><a href=\"https://github.com/mattfarina/farbtastic\">farbtastic 圆环＋正方形</a></li>\n<li><a href></a></li>\n</ul>\n<h4>16. 城市联动</h4>\n<ul>\n<li><a href=\"http://www.ijquery.cn/?p=360\">jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果</a></li>\n<li><a href></a></li>\n</ul>\n<h4>17. 剪贴板</h4>\n<ul>\n<li><a href=\"https://github.com/zeroclipboard/zeroclipboard\">剪贴板</a></li>\n<li><a href=\"http://zenorocha.github.io/clipboard.js/\">clipboard 最新的剪切方案</a></li>\n<li><a href=\"https://github.com/zenorocha/clipboard.js\">不是Flash的剪贴板</a></li>\n</ul>\n<h4>18. 简繁转换</h4>\n<ul>\n<li><a href=\"https://github.com/BYVoid/OpenCC\">简繁转换</a></li>\n</ul>\n<h4>19. 表格 Grid</h4>\n<ul>\n<li><a href=\"http://facebook.github.io/fixed-data-table/\">facebook表格</a></li>\n<li><a href=\"http://handsontable.com/\">类似于Excel编辑表格-handsontable</a></li>\n<li><a href=\"http://bootstrap-table.wenzhixin.net.cn/\">bootstrap-table插件</a></li>\n<li><a href=\"https://www.datatables.net/\">datatables</a></li>\n</ul>\n<h4>20. 在线演示</h4>\n<ul>\n<li><a href=\"http://runjs.cn/\">js 在线编辑 - runjs</a></li>\n<li><a href=\"http://jsbin.com/\">js 在线编辑 - jsbin</a></li>\n<li><a href=\"http://codepen.io/\">js 在线编辑 - codepen</a></li>\n<li><a href=\"http://jsfiddle.net/\">js 在线编辑 - jsfiddle</a></li>\n<li><a href=\"http://ideone.com/\">java 在线编辑 - runjs</a></li>\n<li><a href=\"http://code.hcharts.cn/\">js 在线编辑 - hcharts</a></li>\n<li><a href=\"http://jsdm.com/\">js 在线编辑 - jsdm</a></li>\n<li><a href=\"http://sqlfiddle.com/\">sql 在线编辑 - sqlfiddle</a></li>\n<li><a href=\"https://thimble.mozilla.org\">mozilla 在线编辑器</a></li>\n</ul>\n<h4>21. 播放器</h4>\n<ul>\n<li><a href=\"https://github.com/zmmbreeze/DeadSimpleVideoPlayer\">Html5 VideoPlayer</a></li>\n</ul>\n<h4>22. 粒子动画</h4>\n<ul>\n<li><a href=\"http://a-jie.github.io/Proton/#example\">Proton 烟花</a></li>\n</ul>\n<h3>九. Nodejs</h3>\n<ul>\n<li><a href=\"http://liuqing.pw/\">nodejs 篇幅比较巨大</a></li>\n<li><a href=\"https://github.com/alsotang/node-lessons\">Node.js 包教不包会</a></li>\n<li><a href=\"http://www.rainweb.cn/article/category/Nodejs\">篇幅比较少</a></li>\n<li><a href=\"http://www.w3cfuns.com/article-5598538-1-1.html\">node express 入门教程</a></li>\n<li><a href=\"http://my.oschina.net/u/568264/blog/193773\">nodejs定时任务</a></li>\n<li><a href=\"http://60sky.com/\">一个nodejs博客</a></li>\n<li><a href=\"http://www.cnblogs.com/yexiaochai/p/3536547.html\">【NodeJS 学习笔记04】新闻发布系统</a></li>\n<li><a href=\"http://www.cnblogs.com/qqloving/p/3541099.html\">过年7天乐，学nodejs 也快乐</a></li>\n<li><a href=\"https://github.com/nqdeng/7-days-nodejs\">七天学会NodeJS</a></li>\n<li><a href=\"http://www.cnblogs.com/zhongweiv/p/nodejs_events.html\">Nodejs学习笔记（二）— 事件模块</a></li>\n<li><a href=\"http://www.cnblogs.com/liusuqi/p/3735491.html\">nodejs入门</a></li>\n<li><a href=\"https://github.com/zensh/jsgen\">angularjs nodejs</a></li>\n<li><a href=\"http://blog.fens.me/series-nodejs/\">从零开始nodejs系列文章</a></li>\n<li><a href=\"http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb\">理解nodejs</a></li>\n<li><a href=\"http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\">nodejs事件轮询</a></li>\n<li><a href=\"http://www.nodebeginner.org/index-zh-cn.html\">node入门</a></li>\n<li><a href=\"http://ourjs.com/detail/53e1f281c5910a9806000001\">nodejs cms</a></li>\n<li><a href=\"http://ourjs.com/detail/529ca5950cb6498814000005\">Node初学者入门，一本全面的NodeJS教程</a></li>\n<li><a href=\"http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line/\">NodeJS的代码调试和性能调优</a></li>\n</ul>\n<h3>十. 性能优化</h3>\n<ol>\n<li>\n<p>常规优化</p>\n<ul>\n<li><a href=\"http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering\">Javascript高性能动画与页面渲染</a></li>\n<li><a href=\"http://isux.tencent.com/h5-performance.html\">移动H5前端性能优化指南</a></li>\n<li><a href=\"http://ued.5173.com/?p=1731\">5173首页前端性能优化实践</a></li>\n<li><a href=\"http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers\">给网页设计师和前端开发者看的前端性能优化</a></li>\n<li><a href=\"http://www.orzpoint.com/profiling-css-and-optimization-notes/\">复杂应用的 CSS 性能分析和优化建议</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/tag/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/\">张鑫旭——前端性能</a></li>\n<li><a href=\"http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html\">前端性能监控总结</a></li>\n<li><a href=\"http://udc.weibo.com/2013/05/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bcss%E6%97%A0%E5%9B%BE%E7%89%87%E6%8A%80%E6%9C%AF/\">网站性能优化之CSS无图片技术</a></li>\n<li><a href=\"http://www.aliued.cn/2013/01/20/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E8%B7%AF.html\">web前端性能优化进阶路</a></li>\n<li><a href=\"http://my.eoe.cn/tuwandou/archive/4544.html\">前端技术：网站性能优化之CSS无图片技术</a></li>\n<li><a href=\"http://www.baiduux.com/blog/2011/02/15/browser-loading/\">浏览器的加载与页面性能优化</a></li>\n<li><a href=\"http://www.w3ctech.com/p/1503\">页面加载中的图片性能优化</a></li>\n<li><a href=\"http://www.feelcss.com/tag/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD\">Hey——前端性能</a></li>\n<li><a href=\"http://www.baiduux.com/blog/2010/03/15/html%E4%BC%98%E5%8C%96-2/\">html优化</a></li>\n<li><a href=\"http://www.99css.com/tag/%e6%80%a7%e8%83%bd\">99css——性能</a></li>\n<li><a href=\"http://www.yslow.net/category.php?cid=20\">Yslow——性能优化</a></li>\n<li><a href=\"http://www.cnblogs.com/yslow/\">YSLOW中文介绍</a></li>\n<li><a href=\"http://www.360ito.com/article/40.html\">转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化</a></li>\n<li><a href=\"http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml\">Yahoo!团队实践分享：网站性能</a></li>\n<li><a href=\"http://blog.jiasule.com/i/153\">网站性能优化指南：什么使我们的网站变慢？</a></li>\n<li><a href=\"http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html\">网站性能优化实践，减少加载时间，提高用户体验</a></li>\n<li><a href=\"http://www.umtry.com/archives/747.html\">浅谈网站性能优化 前端篇</a></li>\n<li><a href=\"http://www.adinnet.cn/blog/designview/2012-7-12/678.html\">前端重构实践之如何对网站性能优化？</a></li>\n<li><a href=\"http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9/\">前端性能优化：使用媒体查询加载指定大小的背景图片</a></li>\n<li><a href=\"http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html\">网站性能系列博文</a></li>\n<li><a href=\"http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml\">加载，不只是少一点点</a></li>\n<li><a href=\"http://mzhou.me/article/95310/\">前端性能的测试与优化</a></li>\n<li><a href=\"http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading/\">分享网页加载速度优化的一些技巧？</a></li>\n<li><a href=\"http://www.f2es.com/images-bytes-opt/\">页面加载中的图片性能优化</a></li>\n<li><a href=\"http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html\">web前端优化(基于Yslow)</a></li>\n<li><a href=\"https://www.qianduan.net/website-performance-optimization-tool.html\">网站性能优化工具大全</a></li>\n<li><a href=\"http://www.alloyteam.com/2012/10/high-performance-html/\">【高性能前端1】高性能HTML</a></li>\n<li><a href=\"http://www.alloyteam.com/2012/10/high-performance-css/\">【高性能前端2】高性能CSS</a></li>\n<li><a href=\"http://coolshell.cn/articles/6470.html\">由12306谈谈网站前端性能和后端性能优化</a></li>\n<li><a href=\"http://www.alloyteam.com/webfrontend/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/\">AlloyTeam——前端优化</a></li>\n<li><a href=\"http://www.cnblogs.com/developersupport/p/3248695.html\">毫秒必争，前端网页性能最佳实践</a></li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html\">网站性能工具Yslow的使用方法</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1\">前端工程与性能优化（上）：静态资源版本更新与缓存</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2\">前端工程与性能优化（下）：静态资源管理与模板框架</a></li>\n<li><a href=\"http://blog.jobbole.com/48369/\">HTTPS连接的前几毫秒发生了什么</a></li>\n<li><a href=\"http://uicss.cn/yslow/#more-12319\">Yslow</a></li>\n<li><a href=\"http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1/\">Essential Web Performance Metrics — A Primer, Part 1</a></li>\n<li><a href=\"http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2/\">Essential Web Performance Metrics — Part 2</a></li>\n<li><a href=\"http://jayli.github.io/blog/data/2011/12/23/yuislide.html\">YUISlide,针对移动设备的动画性能优化</a></li>\n<li><a href=\"http://joelglovier.com/improving-site-performance/\">Improving Site Performance</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000367899\">让网站提速的最佳前端实践</a></li>\n<li><a href=\"http://sixrevisions.com/web-development/why-website-speed-is-important/\">Why Website Speed is Important</a></li>\n<li><a href=\"https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance/\">Need for Speed – How to Improve your Website Performance</a></li>\n<li><a href=\"https://github.com/amfe/article/issues/1\">阿里无线前端性能优化指南 (Pt.1 加载期优化) </a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>优化工具</p>\n<ul>\n<li><a href=\"http://www.html-js.com/article/3083\">JavaScript 性能分析新工具 OneProfile</a></li>\n<li><a href=\"http://www.html-js.com/article/3091\">JavaScript 堆内存分析新工具 OneHeap</a></li>\n</ul>\n</li>\n<li>\n<p>在线工具</p>\n<ul>\n<li><a href=\"https://developers.google.com/speed/pagespeed/insights/\">google在线工具</a></li>\n<li><a href=\"http://www.alibench.com/\">阿里测</a></li>\n<li><a href=\"http://itest.aliyun.com/\">阿里-免费测试服务</a></li>\n<li><a href=\"https://github.com/alibaba/f2etest\">阿里-F2etest多浏览器兼容性测试解决方案</a></li>\n<li><a href=\"http://jsperf.com/\">js性能测试</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n</ol>\n<h3>十一. 前端架构</h3>\n<ul>\n<li><a href=\"http://www.zhihu.com/topic/19612641\">技术架构</a></li>\n<li><a href=\"http://saito.im/note/The-Architecture-of-F2E/\">前端架构</a></li>\n<li><a href=\"http://www.zhihu.com/question/24092572\">如何成为前端架构师</a></li>\n<li><a href=\"http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html\">关于前端架构-张克军</a></li>\n<li><a href=\"http://www.zhihu.com/question/25583350\">百度腾讯offer比较（腾讯游戏VS百度基础架构）</a></li>\n<li><a href></a></li>\n</ul>\n<h3>十二. 个人作品</h3>\n<h4>1. 推荐作品</h4>\n<ul>\n<li><a href=\"https://gist.github.com/wintercn\">winter代码片段需要翻墙</a></li>\n<li><a href=\"http://www.fgm.cc/learn/\">fgm</a></li>\n<li><a href=\"https://github.com/hongru/hongru.github.com\">岑安作品集</a></li>\n<li><a href=\"http://kmdjs.github.io/\">当耐特demo集合</a></li>\n<li><a href=\"http://www.laoshu133.com/Lab/\">米空格 js作品</a></li>\n<li><a href=\"http://koen301.github.io/\">myFocus</a></li>\n<li><a href=\"http://panxuepeng.github.io/seajslib/\">SeaJS组件库</a></li>\n<li><a href=\"http://yanhaijing.com/myProject/\">颜海镜作品</a></li>\n<li><a href=\"http://jo2.org/category/myworks/\">脚儿网作品</a></li>\n<li><a href=\"http://www.cnitblog.com/yemoo/category/3107.html\">javascript个人作品</a></li>\n<li><a href=\"http://bbs.miaov.com/forum.php?mod=viewthread&amp;tid=7790\">妙味的雷东升游戏作品</a></li>\n<li><a href=\"http://bbs.csdn.net/topics/380227212\">javascript作品集</a></li>\n<li><a href=\"https://github.com/TooBug/works\">云五笔，灰度产生生成工具</a></li>\n<li><a href=\"http://koen301.github.io/\">项目主页</a></li>\n<li><a href=\"http://zaole.net/\">个性的作品主页</a></li>\n<li><a href=\"http://static.tingall.com/v2/player/\">播放器</a></li>\n<li><a href=\"http://ucren.com/blog/demos\">ucren js demos 集</a></li>\n<li><a href=\"http://www.zhinengshe.com/works_list.html\">智能社</a></li>\n<li><a href=\"http://demos.shizuwu.cn/\">实例陈列架</a></li>\n<li><a href=\"http://zoye.sinaapp.com/demo\">zoye demo</a></li>\n<li><a href=\"http://lab.yuanwai.wang/\">王员外</a></li>\n<li><a href=\"http://pingfan1990.sinaapp.com\">平凡</a></li>\n<li><a href=\"http://www.lovewebgames.com/\">jyg 游戏案例</a></li>\n<li><a href=\"http://www.helloweba.com/list.html\">很多jquery插件</a></li>\n<li><a href=\"http://www.bujichong.com/sojs/api/index.html\">不羁虫 - soJs 作品系列</a></li>\n<li><a href=\"http://frozenui.github.io/case.html\">frozenui</a></li>\n<li><a href=\"http://js-game.github.io/othello/\">黑白棋</a></li>\n<li><a href=\"http://yansm.github.io/fromone/index.html\">fromone</a></li>\n</ul>\n<h4>2. 群员作品</h4>\n<ul>\n<li><a href=\"http://demo.webjyh.com/\">MDialog - [合肥-M.J]</a></li>\n<li><a href=\"http://sandbox.runjs.cn/show/do6zlrrk\">轮播图 - [上海－冷静]</a></li>\n<li><a href=\"http://www.replace5.com/\">[广州—坚壳]</a></li>\n<li><a href=\"http://www.seejs.com/demos/\">[成都 - 无痕]　感恩节专题</a></li>\n<li><a href=\"http://hacke2.github.io/works\">[球霸天]</a></li>\n<li><a href=\"http://www.cnblogs.com/mcat/\">[北京-小数]</a></li>\n<li><a href=\"http://thx.github.io/magix/\">[ptf] Magix 工具</a></li>\n<li><a href=\"http://thx.github.io/magix/\">[杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用</a></li>\n<li><a href=\"http://bh-lay.com/labs/\">[上海-剧中人]-实验室</a></li>\n<li><a href=\"http://jikeytang.github.io\">[上海-豪情 ] 作品集合</a></li>\n<li><a href=\"http://guoshan.sinaapp.com/\">[成都-feeling]</a></li>\n<li><a href=\"http://www.cnblogs.com/liyunhua/\">[上海-angela]</a></li>\n<li><a href=\"http://hcjp.github.io/work/demo/\">[海南-hank]作品</a></li>\n<li><a href=\"https://github.com/yibuyisheng/blogs/issues\">[上海-张力]博客</a></li>\n<li><a href=\"http://zkske121.github.io/\">[上海-zenki]作品</a></li>\n<li><a href=\"http://01google.sinaapp.com/locker.html\">移动端图案解锁</a></li>\n<li><a href=\"https://github.com/webjyh/MPreview.mobile\">[合肥-M.J] - MPreview 移动端图片预览组</a></li>\n<li><a href=\"https://github.com/webjyh/Mexam\">[合肥-M.J] - Mexam 移动端在线做题组</a></li>\n<li><a href=\"http://letyougo.github.io/dancer/\">[北京-苏瑞] - dancer小人</a></li>\n<li><a href=\"http://k.swao.cn/js/\">[上海-玄沐]- 个人网站</a></li>\n<li><a href=\"http://www.meckodo.com/\">[厦门-二哲]- 个人博客</a></li>\n</ul>\n<h4>3. 国外大牛精品</h4>\n<ul>\n<li><a href=\"http://pazguille.me/\">pazguille</a></li>\n</ul>\n<h3>十三. 简历模板</h3>\n<ul>\n<li><a href=\"http://learnshare.github.io/about/index.html\">不错的个人简历</a></li>\n<li><a href=\"http://hcy2367.github.io/resume/\">简历</a></li>\n<li><a href=\"http://ncuey.sinaapp.com/CrispElite/\">张伦</a></li>\n<li><a href=\"https://github.com/hacke2/ResumeSample\">简历</a></li>\n<li><a href=\"http://blog.dandyweng.com/2013/07/how-my-website-was-created/\">翁天信</a></li>\n<li><a href=\"http://www.webhek.com/misc/interactive-resume/\">动画方式的简历</a></li>\n<li><a href=\"http://www.linqing07.com/resume.html\">组件丰富简历</a></li>\n<li><a href=\"http://www.mojianli.com/resume/view\">简历池</a></li>\n<li><a href=\"http://www.haorooms.com/about\">haorooms博客</a></li>\n<li><a href=\"http://cv.youngdze.com/\">Justin Young</a></li>\n<li><a href></a></li>\n</ul>\n<h3>十四. 面试题</h3>\n<ul>\n<li><a href=\"http://www.nowcoder.com/discuss/3196\">那几个月在找工作（百度，网易游戏）</a></li>\n<li><a href=\"http://www.html-js.com/article/1743\">2014最新面试题</a></li>\n<li><a href=\"http://www.w3cfuns.com/thread-5598563-2-1.html\">阿里前端面试题</a></li>\n<li><a href=\"http://www.cnblogs.com/imwtr/p/4685546.html\">2016校招内推 – 阿里巴巴前端 – 三面面试经历 </a></li>\n<li><a href=\"http://www.w3cfuns.com/article-5599657-1-1.html\">腾讯面试题</a></li>\n<li><a href=\"http://www.cnblogs.com/lvdabao/p/3660707.html\">年后跳槽那点事：乐视+金山+360面试之行</a></li>\n<li><a href=\"http://fatesinger.com/2722.html\">阿里前端面试题上线</a></li>\n<li><a href=\"http://www.cnblogs.com/52cik/p/js-question-lg.html\">拉勾网js面试题</a></li>\n<li><a href=\"http://www.cnblogs.com/allenxing/p/3724382.html\">前端面试</a></li>\n<li><a href=\"http://mianshiti.diandian.com/\">Web开发笔试面试题 大全</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000465431\">前端开发面试题</a></li>\n<li><a href=\"https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions\">2014最新前端面试题</a></li>\n<li><a href=\"https://github.com/fex-team/interview-questions\">百度面试</a></li>\n<li><a href=\"http://www.w3cfuns.com/forum.php?mod=forumdisplay&amp;fid=51&amp;filter=typeid&amp;typeid=177\">面试题</a></li>\n<li><a href=\"https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese\">前端工作面试问题</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000465431\">前端开发面试题</a></li>\n<li><a href=\"http://ourjs.com/detail/5%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98\">5个经典的前端面试问题</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000002562454\">最全前端面试问题及答案总结 </a></li>\n<li><a href=\"http://www.html-js.com/article/Large-search-front-team-column%202961\">如何面试一名前端开发工程师？</a></li>\n<li><a href=\"https://github.com/hawx1993/Front-end-Interview-questions\">史上最全 前端开发面试问题及答案整理</a></li>\n<li><a href=\"http://www.cnblogs.com/xiaoruo/p/4665163.html\">前端实习生面试总结 </a></li>\n<li><a href=\"https://github.com/hawx1993/Front-end-Interview-questions\">史上最全 前端开发面试问题及答案整理</a></li>\n<li><a href=\"http://blog.jobbole.com/78738/\">BAT及各大互联网公司2014前端笔试面试题：JavaScript篇</a></li>\n<li><a href=\"https://github.com/paddingme/Front-end-Web-Development-Interview-Question\">前端开发面试题大收集</a></li>\n<li><a href=\"https://github.com/qiu-deqing/FE-interview\">收集的前端面试题和答案</a></li>\n<li><a href=\"http://www.zhihu.com/question/19568008\">如何面试前端工程师</a></li>\n<li><a href=\"https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md\">前端开发面试题</a></li>\n<li><a href=\"http://www.nowcoder.com/discuss?type=2\">牛客网-笔试面经</a></li>\n</ul>\n<h3>十五. iconfont</h3>\n<ul>\n<li><a href=\"http://www.zhihu.com/question/21253343\">中文字体</a></li>\n<li><a href=\"http://iconfont.cn\">淘宝字库</a></li>\n<li><a href=\"http://mux.alimama.com/fonts\">字体</a></li>\n<li><a href=\"http://iconfont.cn/help/platform.html\">制作教程</a></li>\n<li><a href=\"http://www.zhangxinxu.com/wordpress/?s=icomoon\">zhangxinxu-icommon</a></li>\n<li><a href=\"https://icomoon.io/app/\">icommon</a></li>\n<li><a href=\"http://imooc.com/learn/243\">用字体在网页中画ICON图标(推荐教程)</a></li>\n<li><a href=\"http://font-spider.org/\">字体压缩工具</a> 感谢初级群　[深圳-小鱼] 的推荐</li>\n</ul>\n<h3>十六. 开发工具类</h3>\n<ol>\n<li>\n<p>前端开发工具</p>\n<ul>\n<li><a href=\"https://github.com/judasn/IntelliJ-IDEA-Tutorial\">IntelliJ IDEA 简体中文专题教程</a></li>\n<li><a href=\"http://t.cn/8kZZ1Uy\">Webstorm,InterllIdea,Phpstorm</a></li>\n<li><a href=\"https://github.com/jikeytang/sublime-text\">SublimeText</a></li>\n<li><a href=\"https://atom.io/\">Atom</a></li>\n<li><a href=\"https://code.visualstudio.com/\">visual studio code</a></li>\n</ul>\n</li>\n<li>\n<p>Chrome, Firebug, Filddle 调试</p>\n<ol>\n<li>\n<p>Fiddler</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/tugenhua0707/p/4623317.html\">Fiddler调式使用知多少(一)深入研究</a></li>\n<li><a href=\"http://www.cnblogs.com/strick/p/4570006.html\">微信fiddle</a></li>\n<li><a href=\"http://gaoboy.com/article/26.html\">微信fiddle</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>Chrome</p>\n<ul>\n<li><a href=\"https://developer.chrome.com/devtools\">Google Chrome 官方</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4565261.html\">Chrome - 基础</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4579121.html\">Chrome - 进阶</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4585983.html\">Chrome - 性能</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4607497.html\">Chrome - 性能进阶</a></li>\n<li><a href=\"http://www.cnblogs.com/constantince/p/4624241.html\">Chrome - 移动</a></li>\n<li><a href=\"http://www.cnblogs.com/liyunhua/p/4544738.html\">Chrome - 使用技巧</a></li>\n<li><a href=\"http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html\">Chrome - Console控制台不完全指南</a></li>\n<li><a href=\"http://c7sky.com/chrome-devtools-workspace.html\">Chrome - Workspace使浏览器变成IDE</a></li>\n<li><a href=\"http://www.html-js.com/article/Nothing-blind%202975\">network面板</a></li>\n<li><a href=\"http://anti-code.com/devtools-cheatsheet/\">chrome开发工具快捷键</a></li>\n<li><a href=\"http://www.html-js.com/article/2327\">chrome调试工具常用功能整理</a></li>\n<li><a href=\"http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace/\">Chrome 开发工具 Workspace 使用</a></li>\n<li><a href=\"http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html\">Chrome神器Vimium快捷键学习记录 </a></li>\n<li><a href=\"http://www.w3cplus.com/sassguide/debug.html\">sass调试-w3cplus</a></li>\n<li><a href=\"http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html\">如何更专业的使用Chrome开发者工具-w3cplus</a></li>\n<li><a href=\"http://sentsin.com/web/253.html\">chrome调试canvas</a></li>\n<li><a href=\"https://developer.chrome.com/devtools/index\">chrome profiles1</a></li>\n<li><a href=\"http://h5dev.uc.cn/article-25-1.html\">chrome profiles2</a></li>\n<li><a href=\"http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles\">chrome profiles3</a></li>\n<li><a href=\"https://developer.chrome.com/devtools/docs/mobile-emulation\">chrome移动版调试</a></li>\n<li><a href=\"http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool/\">chrome调试</a></li>\n<li><a href=\"http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html\">chrome的调试</a></li>\n<li><a href=\"https://developer.chrome.com/devtools/docs/commandline-api\">chrome console 命令详解</a></li>\n<li><a href=\"http://www.cnblogs.com/leonkao/p/3809655.html\">查看事件绑定1</a></li>\n<li><a href=\"http://www.cnblogs.com/xiaoyao2011/p/3447421.html\">查看事件绑定2</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000000683599\">神器——Chrome开发者工具(一)</a></li>\n<li><a href=\"https://xinranliu.me/2015-05-22-qiqu-performance/\">奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍)</a></li>\n<li><a href=\"http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html\">chrome 开发者工具的 15 个小技巧</a></li>\n<li><a href=\"http://1ke.co/course/361\">Chrome开发者工具不完全指南</a></li>\n<li><a href=\"http://segmentfault.com/a/1190000003882567\">Chrome 开发者工具使用技巧</a></li>\n</ul>\n</li>\n<li>\n<p>Firebug</p>\n<ul>\n<li><a href=\"http://www.imooc.com/learn/137\">firebug视频教程</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE\">firefox 模拟器</a></li>\n<li><a href=\"http://www.cnblogs.com/ctriphire/p/4116207.html\">console.log 命令详解</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html\">Firebug入门指南</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html\">Firebug控制台详解</a></li>\n<li><a href></a></li>\n</ul>\n</li>\n<li>\n<p>移动,微信调试</p>\n<ul>\n<li><a href=\"https://openstf.github.io/\">浏览器端调试安卓</a></li>\n<li><a href=\"http://yujiangshui.com/multidevice-frontend-debug/\">移动端前端开发调试</a></li>\n<li><a href=\"https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md\">使用 Chrome 远程调试 Android 设备</a></li>\n<li><a href=\"http://plus.uc.cn/document/webapp/doc5.html\">mac移动端调试</a></li>\n<li><a href=\"http://www.mihtool.com/\">mac移动端调试</a></li>\n<li><a href=\"http://thx.github.io/mobile/debugging-in-mobile/\">无线调试攻略</a></li>\n<li><a href=\"http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile/\">无线调试攻略</a></li>\n<li><a href=\"http://www.jianshu.com/p/ccf124f1f74b\">屌爆了,完美调试 微信webview(x5)</a></li>\n<li><a href=\"http://liyaodong.com/2015/07/06/%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/\">微信调试的那些事</a></li>\n<li><a href=\"http://jsconsole.com/\">远程console</a></li>\n<li><a href=\"http://blog.qqbrowser.cc/\">微信调试工具</a></li>\n<li><a href=\"https://github.com/jieyou/remote_inspect_web_on_real_device\">各种真机远程调试方法汇总</a></li>\n</ul>\n</li>\n<li>\n<p>iOS Simulator</p>\n<ul>\n<li><a href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/iOS_Simulator_Guide/Introduction/Introduction.html\">Simulator</a></li>\n<li><a href=\"http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary/\">Xcode中的iOS模拟器(iOS Simulator)的介绍和使用心得</a></li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>img</p>\n<ul>\n<li><a href=\"http://preloaders.net/en/circular\">loading img</a></li>\n<li><a href=\"http://zhitu.isux.us/\">智图-图片优化平台</a></li>\n<li><a href=\"https://tinypng.com/\">在线png优化</a></li>\n</ul>\n</li>\n<li>\n<p>生成二维码</p>\n<ul>\n<li><a href=\"http://cli.im/\">生成二维码</a></li>\n</ul>\n</li>\n<li>\n<p>浏览器同步</p>\n<ul>\n<li><a href=\"https://github.com/leeluolee/puer\">puer</a></li>\n<li><a href=\"http://livereload.com/\">liveReload</a></li>\n<li><a href=\"http://getf5.com/\">f5</a></li>\n<li><a href=\"http://geek100.com/2608/\">File Watchers</a></li>\n</ul>\n</li>\n<li>\n<p>在线PPT制作</p>\n<ul>\n<li><a href=\"http://js8.in/2013/11/16/%E6%8E%A8%E8%8D%90nodeppt%EF%BC%9A%E4%BD%BF%E7%94%A8markdown%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%86%99%E7%BD%91%E9%A1%B5ppt/\">nodePPT</a></li>\n<li><a href=\"https://github.com/ksky521/nodePPT\">PPT</a></li>\n<li><a href=\"https://github.com/hakimel/reveal.js/\">reveal</a></li>\n<li><a href=\"https://github.com/Seldaek/slippy\">slippy</a></li>\n</ul>\n</li>\n</ol>\n<h3>十七. 前端导航网站</h3>\n<ul>\n<li><a href=\"http://uxbees.com/index.html\">界面清爽的前端导航</a></li>\n<li><a href=\"http://whycss.com/\">前端导航</a></li>\n<li><a href=\"http://www.daqianduan.com/nav\">前端网址导航</a></li>\n<li><a href=\"http://sentsin.com/daohang/\">前端名录</a></li>\n<li><a href=\"http://123.jser.us/\">前端导航</a></li>\n<li><a href=\"http://www.css88.com/nav/\">前端开发资源</a></li>\n<li><a href=\"http://www.haourl.cn/\">网址导航</a></li>\n<li><a href=\"http://code.ciaoca.com/\">前端开发仓库 - 众多效果的收集地</a></li>\n<li><a href=\"https://github.com/jnoodle/f2e-collect\">前端资源导航</a></li>\n<li><a href=\"http://f2e.im/static/pages/nav/index.html\">F2E 前端导航</a></li>\n</ul>\n<h3>十八. 常用CDN</h3>\n<ul>\n<li><a href=\"http://lib.sinaapp.com/\">新浪CDN</a></li>\n<li><a href=\"http://cdn.code.baidu.com/\">百度静态资源公共库</a></li>\n<li><a href=\"http://libs.useso.com/\">360网站卫士常用前端公共库CDN服务</a></li>\n<li><a href=\"http://www.bootcdn.cn/\">Bootstrap中文网开源项目免费 CDN 服务</a></li>\n<li><a href=\"http://staticfile.org/\">开放静态文件 CDN - 七牛</a></li>\n<li><a href=\"http://www.jq22.com/cdn/\">CDN加速 - jq22</a></li>\n<li><a href=\"http://code.jquery.com/\">jQuery CDN</a></li>\n<li><a href=\"http://www.google-jquery-cdn.com/\">Google jQuery CDN</a></li>\n<li><a href=\"http://www.asp.net/ajax/cdn\">微软CDN</a></li>\n</ul>\n<h3>十九. Git,SVN,Github</h3>\n<ol>\n<li>\n<p>Git</p>\n<ul>\n<li><a href=\"http://git-scm.com/\">git-scm</a></li>\n<li><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">廖雪峰-Git教程</a></li>\n<li><a href=\"https://git-for-windows.github.io/\">git-for-windows</a></li>\n<li><a href=\"http://daemon369.github.io/git/2015/03/10/add-ssh-keys-for-github/\">GitHub 添加 SSH keys</a></li>\n<li><a href=\"http://www.worldhello.net/gotgithub/index.html\">gogithub</a></li>\n<li><a href=\"http://pcottle.github.io/learnGitBranching/\">git常规命令练习</a></li>\n<li><a href=\"https://github.com/xirong/my-git\">git的资料整理</a></li>\n<li><a href=\"http://www.cnblogs.com/fanfan259/p/4810517.html\">我所记录的git命令（非常实用）</a></li>\n<li><a href=\"https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md\">企业开发git工作流模式探索部分休整</a></li>\n<li><a href=\"https://github.com/phodal/github-roam\">GitHub 漫游指南</a></li>\n<li><a href=\"https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md\">GitHub秘籍</a></li>\n<li><a href=\"http://livoras.com/post/28\">使用git和github进行协同开发流程</a></li>\n<li><a href=\"http://onlywei.github.io/explain-git-with-d3/\">动画方式练习git</a></li>\n</ul>\n</li>\n</ol>\n<p>联系我，更多交流</p>\n<p><img src=\"//dn-cnode.qbox.me/FrCbjyzuNmHF1u3j8t26t-cGWPnB\" alt=\"xiaoweiquan.jpeg\"></p>\n</div>",
    "title": "前端资源教程",
    "last_reply_at": "2018-01-30T00:54:50.708Z",
    "good": true,
    "top": false,
    "reply_count": 155,
    "visit_count": 136136,
    "create_at": "2016-03-21T00:22:53.158Z",
    "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
    }
}, {
    "id": "5a69e59e9288dc81532881ee",
    "author_id": "589ac689f46268be08aea5d6",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>之前是做前端的，主要写React。年前跳槽到公司做Node后端。刚入职两天手头还没有什么任务，请问刚开始主要学哪些东西，才能完成前端到后端的一个过渡和思维的转变。</p>\n</div>",
    "title": "前端转Node后端，刚入职，要注意哪些方面",
    "last_reply_at": "2018-01-30T00:43:39.229Z",
    "good": false,
    "top": false,
    "reply_count": 7,
    "visit_count": 600,
    "create_at": "2018-01-25T14:11:42.530Z",
    "author": {
        "loginname": "chaohangz",
        "avatar_url": "https://avatars2.githubusercontent.com/u/15074003?v=4&s=120"
    }
}, {
    "id": "5a68d49fafa0a121784a8f48",
    "author_id": "52c005d28a716e0b1578f9cc",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>好久不见，Yorkie 最近做了一个小东西，在此分享给大家！</p>\n<p>先放个链接：<a href=\"https://github.com/Rokid/shadow-node\">https://github.com/Rokid/shadow-node</a>\n从名字来看，他可不是一个 Node.js 的 C++ Addon，而是可以运行 Node.js 程序的另一个运行时（Runtime），相比 Node.js，具有更快的启动速度以及更小的内存占用、更加节省内存的模块加载方式！原来一个 Node.js 应用需要好几十M的运行时内存，现在可能只需要几兆就可以搞定了，并且拥有更快的启动速度。这也是因为 ShadowNode 不再使用 v8 作为 JavaScript 引擎，而是使用一款三星出品的 JerryScript 在做底层的解释执行！</p>\n<p>ShadowNode 目前支持的模块还比较有限，不过一些基础的如 HTTP/NET/DNS/Child Process 等都是支持的，并且除此之外，还默认支持 DBus 通讯方式，对于像 Linux 平台，简直是不要太方便，另外，对于硬件玩家，如果有兴趣移植到自己的开发板上的，也支持了诸如 I2C/ADC/GPIO 等这样的硬件接口，也就是说接入硬件仅仅写写脚本就能把你的硬件玩起来！另外，也可以把他移植到你家里的任意设备上，作为脚本语言使用，也是不错的选择！</p>\n<p>在此，我对 ShadowNode 寄予着非常大的希望，目前 Node.js 在嵌入式设备来说，无可避免都是内存占用的大户，之前 Tessel 曾经尝试把 JavaScript代码编译成 Lua 来达到降低内存的目的，也有一些不同的开发板使用像 JerryScript 这样低内存的引擎／虚拟机，然后仅仅支持了部分简单的模块以及 CommonJS，而我完全希望 ShadowNode 将更完全地支持 Node.js/Npm 模块，能够让 JavaScript 开发者能无缝在 Node.js 与 ShadowNode 中切换，尽量少地减少学习的成本！另外，ShadowNode 底层使用纯 C 编写，我们将大部分代码交给 C 来实现，JavaScript 仅仅作为胶水层语言！</p>\n<p>最后，搭车招个人！坐标杭州西溪，Rokid 公司，招募嵌入式、服务端以及社区增长黑客，共同点都是要热爱 JavaScript 以及 Node.js，简历的话直接去我 GitHub 邮件我就好了～</p>\n</div>",
    "title": "ShadowNode: 以更轻量级的方式使用 Node.js",
    "last_reply_at": "2018-01-29T15:44:52.090Z",
    "good": true,
    "top": false,
    "reply_count": 26,
    "visit_count": 919,
    "create_at": "2018-01-24T18:46:55.269Z",
    "author": {
        "loginname": "yorkie",
        "avatar_url": "https://avatars3.githubusercontent.com/u/1935767?v=4&s=120"
    }
}, {
    "id": "5a6f30b59288dc8153288344",
    "author_id": "596df77cdb0b6aec18a28643",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>关键代码\nvar rawstream = new Readable({\n\t\t\t\thighWaterMark : 128 * 1024,\n\t\t\t\tread(size) {\n\t\t\t\t}\n\t\t\t});</p>\n<p>rawstream.pipe(zlib.createGunzip())</p>\n<p>然后后续会不停的rawstream.push一些binary的数据</p>\n<p>有时候客户端可能会传过来损坏的gzip数据\n然后就会Gunzip.zlibOnError 把整个node进程崩掉\n我试了rawstream.on(‘error’, function(err){</p>\n<p>});\n并不能捕获到error\n求教 有什么办法至少能不让node崩掉？</p>\n</div>",
    "title": "Gunzip.zlibOnError会把整个node进程崩掉",
    "last_reply_at": "2018-01-29T15:06:02.882Z",
    "good": false,
    "top": false,
    "reply_count": 6,
    "visit_count": 91,
    "create_at": "2018-01-29T14:33:25.383Z",
    "author": {
        "loginname": "hzqst",
        "avatar_url": "https://avatars1.githubusercontent.com/u/12287588?v=4&s=120"
    }
}, {
    "id": "5a311f729807389a1809f37a",
    "author_id": "57b99bc2dcaeb5d932db220a",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h1>Web性能</h1>\n<p>从底层计算机网络协议到应用层各个方面去理解Web性能。目前项目处于刚开始阶段，欢迎对性能优化感兴趣的同学共同参与总结！</p>\n<p>Github: <a href=\"https://github.com/laoqiren/web-performance\">https://github.com/laoqiren/web-performance</a></p>\n<h2>目录</h2>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/README.md\">网页渲染原理</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">渲染过程</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.md\">资源加载顺序</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.md\">浏览器优化策略</a></li>\n<li><a href=\"/%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/repaint%E4%B8%8Ereflow.md\">repaint与reflow</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F\">带宽与延迟</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%BC%80%E5%A7%8B.md\">从输入URL开始</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F/%E5%B8%A6%E5%AE%BD%E4%B8%8E%E5%BB%B6%E8%BF%9F.md\">带宽与延迟</a></li>\n<li>TCP协议细节</li>\n<li>HTTP 1.x性能</li>\n<li>针对性优化</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/README.md\">缓存机制</a>\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5.md\">首部字段</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA.md\">浏览器行为</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/%E4%BC%98%E5%8C%96.md\">优化</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/tree/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90\">静态资源</a>\n<ul>\n<li>减少请求</li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9.md\">资源压缩</a></li>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/%E5%9B%BE%E5%83%8F%E4%BC%98%E5%8C%96.md\">图片资源优化</a></li>\n<li>Webpack</li>\n<li>CDN</li>\n</ul>\n</li>\n<li>Virtual DOM\n<ul>\n<li><a href=\"https://github.com/laoqiren/web-performance/blob/master/%E8%99%9A%E6%8B%9FDOM/React%E5%9F%BA%E7%A1%80.md\">React基础</a></li>\n<li>实现</li>\n<li>diff算法</li>\n<li>性能考虑</li>\n</ul>\n</li>\n<li>SPA与SSR\n<ul>\n<li>SPA问题</li>\n<li>服务端渲染</li>\n<li>同构应用</li>\n<li>性能问题</li>\n</ul>\n</li>\n<li>HTTP2\n<ul>\n<li>新特性概览</li>\n<li>性能提升</li>\n<li>工程实践</li>\n</ul>\n</li>\n<li>HTTPS性能影响\n<ul>\n<li>TLS原理</li>\n<li>性能影响</li>\n</ul>\n</li>\n<li>高性能JavaScript\n<ul>\n<li>V8与JIT</li>\n<li>内存泄露</li>\n<li>GC机制</li>\n<li>算法与流程</li>\n<li>Web worker</li>\n</ul>\n</li>\n<li>WebAssembly</li>\n<li>PWA与离线应用</li>\n<li>即时运用与P2P</li>\n<li>Node.js性能优化</li>\n<li>集群与负载均衡</li>\n<li>数据库相关</li>\n<li>性能测试\n<ul>\n<li>Chrome开发者工具</li>\n<li>benchmark</li>\n<li>压力测试</li>\n</ul>\n</li>\n</ul>\n<h2>引用说明</h2>\n<p>此项目会引用许多其他文章书籍的图片或部分内容，我会尽量都加以注明，如果有部分遗漏以致于侵犯到您的版权，烦请联系我修改！此项目旨在整理零碎的知识和实践方案，方便交流学习，请勿用于商业用途。</p>\n<h2>参与贡献</h2>\n<ul>\n<li>提想法和建议</li>\n<li>纠错完善</li>\n<li>增加新章节或内容</li>\n</ul>\n</div>",
    "title": "性能优化知识与实践整理",
    "last_reply_at": "2018-01-29T13:33:56.004Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 1554,
    "create_at": "2017-12-13T12:39:14.755Z",
    "author": {
        "loginname": "laoqiren",
        "avatar_url": "https://avatars2.githubusercontent.com/u/16136702?v=4&s=120"
    }
}, {
    "id": "5a2e6e79d92f2f5b185acd98",
    "author_id": "50b5bc5d637ffa4155091236",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>如果路由在后端，那是不是页面层都要从后台取，这样好象就是以前的模式 不能算前后台分离了</p>\n</div>",
    "title": "前后台分离是不要必须要在前端实现路由？",
    "last_reply_at": "2018-01-29T12:53:37.532Z",
    "good": false,
    "top": false,
    "reply_count": 15,
    "visit_count": 1290,
    "create_at": "2017-12-11T11:39:37.691Z",
    "author": {
        "loginname": "yakczh",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"
    }
}, {
    "id": "5a6f16f79d371d4a059eef8a",
    "author_id": "59fbcfd75e33e3bb7496e7f6",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>自己个人的小项目, 主要想监测下 response time, 资源消耗等情况, Datadog 和 OneAPM 老大哥都是收费的, 没必要上,\n或者有开源的替代品么 ?</p>\n<p>老哥们推荐一波 ~</p>\n<p>:D</p>\n</div>",
    "title": "Node AMP 性能检测工具求推荐 ~",
    "last_reply_at": "2018-01-29T12:49:20.460Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 94,
    "create_at": "2018-01-29T12:43:35.486Z",
    "author": {
        "loginname": "iShawnWang",
        "avatar_url": "https://avatars0.githubusercontent.com/u/20266594?v=4&s=120"
    }
}, {
    "id": "5a6b3e189d371d4a059eeeed",
    "author_id": "5a5c0a17a3692d014f4f1477",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>浏览器 录音得到的blob 数据传到 后台，express框架用 multer接收，保存后，，播放没声音。。。</p>\n<p>怎么回事呢。。。。</p>\n<p>求大佬 赐教！！！</p>\n</div>",
    "title": "浏览器 录音得到的blob 数据传到 后台，express框架用 multer接收，保存后，，播放没声音。。。",
    "last_reply_at": "2018-01-29T11:25:43.853Z",
    "good": false,
    "top": false,
    "reply_count": 8,
    "visit_count": 355,
    "create_at": "2018-01-26T14:41:28.556Z",
    "author": {
        "loginname": "1160007652",
        "avatar_url": "https://avatars3.githubusercontent.com/u/26641790?v=4&s=120"
    }
}, {
    "id": "5a6eff149d371d4a059eef86",
    "author_id": "576a5d4063075514079b77e7",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>翻译一篇国外哥们做的JavaScript 现状调查</p>\n<p>欢迎阅读 <a href=\"https://www.liayal.com/article/5a6ece2aeba8a1470c87f931\">2017年JavaScript 现状调查报告总结</a></p>\n</div>",
    "title": "2017年JavaScript 现状调查报告总结",
    "last_reply_at": "2018-01-29T11:01:40.541Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 177,
    "create_at": "2018-01-29T11:01:40.541Z",
    "author": {
        "loginname": "MaelWeb",
        "avatar_url": "https://avatars1.githubusercontent.com/u/7869311?v=4&s=120"
    }
}, {
    "id": "5a6ec0edafa0a121784a90db",
    "author_id": "5a6ebfaa9288dc8153288322",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var timer = setInterval(function () {\n\tconsole.log(new Date, 1)\n}, 1000)\n\nvar fn = function () {\n\tconsole.log(new Date, 2)\n}\n\nvar timer2 = setInterval(fn, 1000)\ntimer2.unref()\n</code></pre><p>在这里一直会间断输出1， 2，  为什么timer2 的回调没有被取消</p>\n<ul>\n<li>使timer2正常unref\n1.但是将timer 这段代码去除就可以正常的取消timer2 的回调了，\n2、timer 也加上 unref</li>\n</ul>\n<p><strong><em>难道是永远只能有一个setInterval 在event loop中才能使用unref 生效吗</em></strong></p>\n</div>",
    "title": "time.unref 没有按预期取消对应的函数回调",
    "last_reply_at": "2018-01-29T10:22:03.457Z",
    "good": false,
    "top": false,
    "reply_count": 9,
    "visit_count": 183,
    "create_at": "2018-01-29T06:36:29.089Z",
    "author": {
        "loginname": "dmodaii",
        "avatar_url": "https://avatars1.githubusercontent.com/u/16190100?v=4&s=120"
    }
}, {
    "id": "5a6dab899288dc81532882da",
    "author_id": "58de5214b3e60b982d089dc3",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>年纪大了快要撤回老家了, 西安基本没有node的机会, 已经学了一段时间java了, 你们有什么想说的😅\n<img src=\"//dn-cnode.qbox.me/FrLDAbf8qA3JKbhpABNC6ecHRh59\" alt=\"image.png\"></p>\n</div>",
    "title": "不得已要放下node, 转java了",
    "last_reply_at": "2018-01-29T10:17:19.429Z",
    "good": false,
    "top": false,
    "reply_count": 29,
    "visit_count": 1228,
    "create_at": "2018-01-28T10:52:57.720Z",
    "author": {
        "loginname": "XiaozhongLiu",
        "avatar_url": "https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"
    }
}, {
    "id": "5a6eeecb9d371d4a059eef7f",
    "author_id": "51ece401f4963ade0e95513a",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><blockquote>\n<p>这篇文章主要介绍nextTick和RunMicrotasks的主要流程和涉及到的相关源码，<em>对于timers相关api在event-loop中的表现不做解读</em></p>\n</blockquote>\n<h3>nextTick实现</h3>\n<p>目光直接转移到<a href=\"https://github.com/nodejs/node/blob/master/lib/internal/process/next_tick.js\">next_tick.js</a>，整体nextTick的代码其实很容易理解：</p>\n<pre class=\"prettyprint language-js\"><code> const [\n    tickInfo,\n    runMicrotasks\n  ] = process._setupNextTick(_tickCallback);\nfunction nextTick(callback) {\n   &#x2F;&#x2F; ...\n   nextTickQueue.push(new TickObject(callback, args, getDefaultTriggerAsyncId()));\n  }\nfunction _tickCallback() {\n    let tock;\n    do {\n      while (tock = nextTickQueue.shift()) {\n      &#x2F;&#x2F; ...\n      const callback = tock.callback;\n        if (tock.args === undefined)\n          callback();\n      runMicrotasks();\n    } while (nextTickQueue.head !== null || emitPromiseRejectionWarnings());\n    tickInfo[kHasPromiseRejections] = 0;\n  }\n</code></pre><p>通过这两个函数，就能看出来整个nextTick是如何工作的。</p>\n<ul>\n<li>nextTickQueue为记录nextTick的数组，有新的nextTick注册进来就会被推入数组</li>\n<li>_tickCallback则会不断的推出数组中的元素然后运行</li>\n</ul>\n<p>大家注意一下<code>process._setupNextTick(_tickCallback)</code>，最终这个_tickCallback并没有在js中执行，而是传递给了c++：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; node.cc\nvoid SetupNextTick(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Environment* env = Environment::GetCurrent(args);\n  CHECK(args[0]-&gt;IsFunction());\n  env-&gt;set_tick_callback_function(args[0].As&lt;Function&gt;());\n  &#x2F;&#x2F; ...\n</code></pre><p>在这里可以看出来，最终_tickCallback丢给了<code>tick_callback_function</code>，然后在<code>LoadEnvironment</code>中通过<code>_setupNextTick</code>触发运行（<code>LoadEnvironment</code>之前详细介绍过，在这里不做过多介绍）,在这里简单的追踪了一下_tickCallback来证实一下最终_tickCallback传递给了<code>tick_callback_function</code>：</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(()=&gt;console.log(2))\n</code></pre><p><img src=\"https://github.com/xtx1130/blog/raw/master/images/issue16/issue16-1.png\" alt=\"issue16-1\"></p>\n<p>tips: 蓝色底色代码为断点所在位置，下方为此时刻的内存地址，上面这张图可以看出来在没有跑<code>LoadEnvironment</code>的时候，<code>tick_callback_function</code>为NULL</p>\n<p><img src=\"https://github.com/xtx1130/blog/raw/master/images/issue16/issue16-2.png\" alt=\"issue16-2\">\n如果对<code>LoadEnvironment</code>比较了解的读者，应该是明白其中的原理的，如果不明白原理可以简单看一下<code>tick_callback_function</code>这里的内存变化。这里我们假设读者了解node启动的所有机制，那么就会发现一件事情：<strong>在<code>process.nextTick</code>运行的时候，<code>uv_run</code>尚未启动</strong>。<br>\n那么，我们可以根据这个显现得出一个比较<em>浅显</em>的结论：<strong><code>process.nextTick</code>会阻塞libuv的事件循环</strong>。(这是在node初始化<em>bootatrap</em>阶段的情况。即使在evnt_loop中,表现也是一样的。为何用这个阶段来叙述，是因为这个阶段最容易追踪和解读)</p>\n<h3>process.nextTick和RunMicrotasks</h3>\n<p>通过前一章节的叙述和上一篇文章对setTimeout流程的分析，我们可以发现：<strong><code>process.nextTick</code>不是基于libuv事件机制的，而timers一系列的api全部是基于libuv开放出来的api实现的</strong>。那么这个nextTick到底是如何实现的呢？<br>\n接下来就要从nextTick的源码聊起了：</p>\n<pre class=\"prettyprint language-js\"><code>function _tickCallback() {\n    let tock;\n    do {\n      while (tock = nextTickQueue.shift()) {\n      &#x2F;&#x2F; ...\n      const callback = tock.callback;\n        if (tock.args === undefined)\n          callback();\n     &#x2F;&#x2F; ...\n     }\n      runMicrotasks();\n    } \n  &#x2F;&#x2F; ...\n  }\n</code></pre><p>在执行完nextTick之后（<code>callback()</code>）还继续执行了<code>runMicrotasks</code>，我相信如果了解过Microtasks的读者肯定知道这到底是做什么的，接下来我们深扒一下这个<code>runMicrotasks</code>：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; src&#x2F;node.cc\nv8::Local&lt;v8::Function&gt; run_microtasks_fn =\n      env-&gt;NewFunctionTemplate(RunMicrotasks)-&gt;GetFunction(env-&gt;context())\n          .ToLocalChecked();&#x2F;&#x2F;v8 吐出来的方法 RunMicrotasks\nrun_microtasks_fn-&gt;SetName(\n      FIXED_ONE_BYTE_STRING(env-&gt;isolate(), &quot;runMicrotasks&quot;));\n\n&#x2F;&#x2F; deps&#x2F;v8&#x2F;src&#x2F;isolate.cc\nvoid Isolate::RunMicrotasks() {&#x2F;&#x2F; v8中RunMicrotasks实现\n  &#x2F;&#x2F; Increase call depth to prevent recursive callbacks.\n  v8::Isolate::SuppressMicrotaskExecutionScope suppress(\n      reinterpret_cast&lt;v8::Isolate*&gt;(this));\n  is_running_microtasks_ = true;\n  RunMicrotasksInternal();\n  is_running_microtasks_ = false;\n  FireMicrotasksCompletedCallback();\n}\nvoid Isolate::RunMicrotasksInternal() {\n  if (!pending_microtask_count()) return;\n  TRACE_EVENT0(&quot;v8.execute&quot;, &quot;RunMicrotasks&quot;);\n  TRACE_EVENT_CALL_STATS_SCOPED(this, &quot;v8&quot;, &quot;V8.RunMicrotasks&quot;);\n  while (pending_microtask_count() &gt; 0) {\n    HandleScope scope(this);\n    int num_tasks = pending_microtask_count();\n    Handle&lt;FixedArray&gt; queue(heap()-&gt;microtask_queue(), this);\n    DCHECK(num_tasks &lt;= queue-&gt;length());\n    set_pending_microtask_count(0);\n    heap()-&gt;set_microtask_queue(heap()-&gt;empty_fixed_array());\n  &#x2F;&#x2F; ...\n</code></pre><p>通过上面的代码，可以比较清晰地看到整个<code>RunMicrotasks</code>的全过程，主要就是通过microtask_queue来实现的Microtask。\n了解了整个流程，可以很容易得出一个结论：<strong>nextTick会在v8执行Microtasks之前对在js中注册的nextTickQueue逐个执行，即阻塞了Microtasks执行。</strong></p>\n<h3>bootstrap阶段和event-loop时候的异同</h3>\n<p>通过上面的分析，下面这段代码在bootstrap阶段，应该很容易理解：</p>\n<pre class=\"prettyprint language-js\"><code>setTimeout(()=&gt;console.log(&#x27;timers API&#x27;),0)&#x2F;&#x2F;uv_run开始运行后才执行timers相关api，最后执行\nconsole.log(&#x27;bootstrap&#x27;)&#x2F;&#x2F;在node LoadEnvironment(bootstrap)阶段执行，最先执行\nnew Promise((resolve,reject)=&gt; resolve(&#x27;microtask run&#x27;)).then(arg =&gt; console.log(arg))&#x2F;&#x2F;注册到microtask_queue中\nprocess.nextTick(()=&gt;console.log(&#x27;run next tick&#x27;))&#x2F;&#x2F; 会在microtask之前运行\n</code></pre><p>结果如图：\n<img src=\"https://github.com/xtx1130/blog/raw/master/images/issue16/issue16-3.png\" alt=\"issue16-3\">\n相关解释已经写到了上面的注释中。  （当然这里用console来作为同步代码不是很严谨，不过比较直观）</p>\n<p>那么在event-loop中是如何表现的呢？在上文中也提到过一句：</p>\n<blockquote>\n<p>这是在node初始化，即<em>bootstrap</em>的情况下，即使在evnt_loop中,表现也是一样的</p>\n</blockquote>\n<p>event-loop中的区别是：<strong>本应该在node LoadEnvironment(bootstrap)阶段执行的代码的运行转移到了<code>InternalMakeCallback</code>中</strong>。<br>\n下面是<code>InternalMakeCallback</code>的代码：</p>\n<pre class=\"prettyprint language-c\"><code>&#x2F;&#x2F; .&#x2F;src&#x2F;node.cc\nMaybeLocal&lt;Value&gt; InternalMakeCallback(Environment* env,\n                                       Local&lt;Object&gt; recv,\n                                       const Local&lt;Function&gt; callback,\n                                       int argc,\n                                       Local&lt;Value&gt; argv[],\n                                       async_context asyncContext) {\n  CHECK(!recv.IsEmpty());\n  InternalCallbackScope scope(env, recv, asyncContext);\n  if (scope.Failed()) {\n    return Undefined(env-&gt;isolate());\n  }\n\n  MaybeLocal&lt;Value&gt; ret;\n\n  {\n    ret = callback-&gt;Call(env-&gt;context(), recv, argc, argv);\n    &#x2F;&#x2F; ...\n  }\n &#x2F;&#x2F; ...\n  return ret;\n}\n</code></pre><p>通过<code>ret = callback-&gt;Call(env-&gt;context(), recv, argc, argv);</code>实现了event-loop中主体代码的运行，之后在InternalMakeCallback结束之后，实现对nextTick和microtask的调用，代码如下：</p>\n<pre class=\"prettyprint language-c\"><code>&#x2F;&#x2F; .&#x2F;src&#x2F;node.cc\nvoid InternalCallbackScope::Close() {\n  &#x2F;&#x2F; ...\n  Environment::TickInfo* tick_info = env_-&gt;tick_info();\n\n  if (!tick_info-&gt;has_scheduled()) {\n    env_-&gt;isolate()-&gt;RunMicrotasks();\n  }\n  &#x2F;&#x2F; ...\n  if (!tick_info-&gt;has_scheduled() &amp;&amp; !tick_info-&gt;has_promise_rejections()) {\n    return;\n  }\n  &#x2F;&#x2F; ...\n  Local&lt;Object&gt; process = env_-&gt;process_object();\n\n  if (env_-&gt;tick_callback_function()-&gt;Call(process, 0, nullptr).IsEmpty()) {\n    failed_ = true;\n  }\n}\n</code></pre><p>其中，有两个需要注意的地方，一个是：</p>\n<pre class=\"prettyprint language-c++\"><code> if (!tick_info-&gt;has_scheduled()) {\n    env_-&gt;isolate()-&gt;RunMicrotasks();\n  }\n &#x2F;&#x2F; ...\n  if (!tick_info-&gt;has_scheduled() &amp;&amp; !tick_info-&gt;has_promise_rejections()) {\n    return;\n  }\n</code></pre><p>这两处代码专门针对无process.nextTick行为的event-loop进行了处理，直接从node中调用v8的RunMicrotasks，加快整体处理速度。<br>\n另外一个地方是：</p>\n<pre class=\"prettyprint language-c++\"><code>if (env_-&gt;tick_callback_function()-&gt;Call(process, 0, nullptr).IsEmpty()) {\n    failed_ = true;\n  }\n</code></pre><p>通过对tick_callback_function的调用，实现触发之前讲过的<code>_tickCallback</code>,不知道大家还记得这句话么：</p>\n<blockquote>\n<p>在这里简单的追踪了一下_tickCallback来证实一下最终_tickCallback传递给了<code>tick_callback_function</code></p>\n</blockquote>\n<p>这样，整体形成了一个闭环，无论是bootstrap阶段还是在event-loop阶段，总是能保证两点：</p>\n<ul>\n<li>nextTick永远在主函数（包括同步代码和console）运行完之后运行</li>\n<li>nextTick永远优先于microtask运行</li>\n</ul>\n<p>by 小菜\n原文地址：<a href=\"https://github.com/xtx1130/blog/issues/16\">https://github.com/xtx1130/blog/issues/16</a>，欢迎star和watch，如果文中有讲解错误的地方欢迎指正</p>\n</div>",
    "title": "node源码粗读（7）：nextTick和microtasks从bootstrap到event-loop全阶段解读",
    "last_reply_at": "2018-01-29T09:52:11.844Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 111,
    "create_at": "2018-01-29T09:52:11.844Z",
    "author": {
        "loginname": "xtx1130",
        "avatar_url": "https://avatars2.githubusercontent.com/u/5475069?v=4&s=120"
    }
}, {
    "id": "5a6edba9ce45d440451464bc",
    "author_id": "578f933cb78759e813a57ae6",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>现在找人都比较看经验呢，之前一直是干的产品，越做越不顺心，思考一番决定转行。\n也用Node写过小玩意，但是吧肯定上不了台面。也不能说自己闷头学个一年半年再来找。\n想问问有没有前辈也是转行的成功，讨教些经验，小弟在此谢过啦~</p>\n</div>",
    "title": "3年产品转node，怎么样比较顺利的拿到面试机会",
    "last_reply_at": "2018-01-29T09:31:30.921Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 189,
    "create_at": "2018-01-29T08:30:33.497Z",
    "author": {
        "loginname": "webzmy",
        "avatar_url": "https://avatars.githubusercontent.com/u/20560499?v=3&s=120"
    }
}, {
    "id": "5a6addc99d371d4a059eeec2",
    "author_id": "57ff53e527a1d99178a98e23",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>最经在搭一个koa2+react的ssr架构，遇到个问题，path=&quot;/“需要重定向到path=”/home&quot;\njsx里面用到&lt;Route path=&quot;/&quot; render={() =&gt; &lt;Redirect to=&quot;/home&quot; /&gt;} /&gt;\nssr用到的代码如下\nssr-entry.js\n<img src=\"//dn-cnode.qbox.me/FhzeIptlddUzZZVha_Ie4bXA1ok-\" alt=\"1516951924(1).jpg\">\nserver.js\n<img src=\"//dn-cnode.qbox.me/FmvxwqNHt_BbH9A3UILIXml6EuTS\" alt=\"1516952176(1).jpg\"></p>\n<p>可以看到我现在是那ctx.url判断写死重定向到/home的\n但实际上按照react-router V4的官方文档，</p>\n<p>我应该在<code>const app = await serverBundle(store, routerContext, ctx.url);</code>之后去判断routerContext.url是否存在。\n但是当我按照官方文档的写法，访问path=&quot;/&quot;的路径，routerContext依然是{}。\n<img src=\"//dn-cnode.qbox.me/Fr-DQVR7V6s8wYBRv8ZOJH7_ZM2h\" alt=\"1516952527(1).jpg\">\n<img src=\"//dn-cnode.qbox.me/FuP5nTbchidezH8gzo7W31fCABGB\" alt=\"1516952891(1).jpg\">\n可以看到访问/的时候，打印的routerContext依然为{}</p>\n<p>希望我表述清楚了，求大牛给支个招，是我少做了哪一步吗？之前用express做过是没问题的。</p>\n</div>",
    "title": "koa2+react搭建ssr时，服务端做重定向时不能正确拿到StaticRouter处理过后的context",
    "last_reply_at": "2018-01-29T07:35:38.996Z",
    "good": false,
    "top": false,
    "reply_count": 6,
    "visit_count": 398,
    "create_at": "2018-01-26T07:50:33.444Z",
    "author": {
        "loginname": "chtic123",
        "avatar_url": "https://avatars1.githubusercontent.com/u/15922086?v=4&s=120"
    }
}, {
    "id": "5a6748a9ce45d440451462ad",
    "author_id": "57d216e13d3520a5387c2b53",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>RT</p>\n</div>",
    "title": "大家好，请问在mongodb的数据库优化上面，有哪方面的建议吗？",
    "last_reply_at": "2018-01-29T06:48:06.655Z",
    "good": false,
    "top": false,
    "reply_count": 7,
    "visit_count": 615,
    "create_at": "2018-01-23T14:37:29.556Z",
    "author": {
        "loginname": "a69694510",
        "avatar_url": "https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"
    }
}, {
    "id": "5933d125739a92064a1bd4b6",
    "author_id": "590d7e623504ce1c2ac45912",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><blockquote>\n<p><a href=\"http://cnodejs.org/topic/59294bff9e32cc84569a746a\">【Node.js 微信公众号实战】1.Node.js 接入微信公众平台开发</a>\n<a href=\"http://cnodejs.org/topic/5933d125739a92064a1bd4b6\">【Node.js 微信公众号实战】2.Node.js access_token的获取、存储及更新</a>\n<a href=\"https://cnodejs.org/topic/593668946b7ebe7e2979d8c6\">【Node.js 微信公众号实战】3.Node.js 自定义微信菜单</a>\n<a href=\"https://cnodejs.org/topic/5939fa64d3575f1303de3aab\">【Node.js 微信公众号实战】4.Node.js 微信消息管理</a></p>\n</blockquote>\n<h2>一、写在前面的话</h2>\n<p>  上一篇文章中，我们使用 Node.js 成功的实现了接入微信公众平台功能。在这篇文章中，我们将实现微信公众平台一个非常重要的参数 access_token ,它是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用 access_token。</p>\n<p>  在开始之前，让我们先按捺住自己激动的心情、调整好呼吸，因为我们要将上一篇文章的代码重新整理一下。一个好的项目结构，更能有助于我们理清业务逻辑以及将来维护代码的便捷。OK!\n<img src=\"http://img.blog.csdn.net/20170528115031656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Are you ready?\"></p>\n<h2>二、整理项目结构</h2>\n<p>1.打开我们的项目，并在项目中添加文件夹，命名为 wechat ，如图:\n<img src=\"http://img.blog.csdn.net/20170604122937701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>2.在 wechat 文件夹中添加文件并命名为 wechat.js。wechat.js 主要用于封装开发微信公众平台的所有方法。首先我们构建这个模块的结构，代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27; &#x2F;&#x2F;设置为严格模式\n\n&#x2F;&#x2F;构建 WeChat 对象 即 js中 函数就是对象\nvar WeChat = function(config){\n    &#x2F;&#x2F;设置 WeChat 对象属性 config\n    this.config = config;\n    \n    &#x2F;&#x2F;设置 WeChat 对象属性 token\n    this.token = config.token;\n}\n\n&#x2F;&#x2F;暴露可供外部访问的接口\nmodule.exports = WeChat;\n</code></pre><p> 严格模式：是在 ECMAScript 5 中引入的概念。严格模式是为 Javascript 定义了一种解析与执行模型。</p>\n<p> module.exports ：暴露接口用于外部操作。实际上我们定义模块后，使用 node.js 的 require 引用时，node.js 会自动在我们定义的模块外层加入以下代码</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * exports  module.exports 的一个简短的引用\n * require  用于引入模块\n * module   当前模块的引用\n * __filename  当前模块的文件名\n * __dirname   当前模块的目录名\n *&#x2F;\n(function (exports, require, module, __filename, __dirname) {\n    &#x2F;&#x2F;自定义模块的代码块\n})();\n</code></pre><p>相信对于有过 javascript 开发经验的同学，上面的代码并不陌生。我们可以将它理解为一个闭包，是一个匿名方法的调用，避免污染全局变量。</p>\n<blockquote>\n<p>小知识：</p>\n<p>  在上面的代码中，除了我们所使用的 module.exports 对象，还有另一个用于暴露接口的 变量 exports (官方文档将 module.exports 称为对象，exports 称为 属性，我在这里也就这样称呼了)，那么 module.exports 与 exports 有什么区别呢？</p>\n<p>  module.exports 对象是由模块系统创建的，exports 变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于 module.exports 的值。——<a href=\"https://nodejs.org/dist/latest-v6.x/docs/api/modules.html#modules_module_exports\">来自Node.js官方文档</a></p>\n<p>  也就是说 exports 是 module.exports 的引用，而 module.exports 才是真正用于暴露接口的对象。 exports 赋值的所有属性与方法都赋值给了 module.exports 对象。</p>\n<p>  如果 module.exports 与 exports 将值赋值给了相同的属性，则按照赋值的先后顺序，取最后一个赋值；如果我们给 module.exports 赋值的是一个对象，则会覆盖 exports 的所有方法与属性。</p>\n<p>  因此我们在暴露接口的使用上，如果只是单一属性或方法的话，建议使用exports.属性/方法，要是导出多个属性或方法或使用对象构造方法，建议使用 module.exports。</p>\n<p>  具体详解可以点击查看该文章 -&gt; <a href=\"https://www.ycjcl.cc/2017/02/10/module-exportshe-exportsde-qu-bie/?utm_source=tuicool&amp;utm_medium=referral\">Module.exports和exports的区别</a></p>\n</blockquote>\n<p>3.为 WeChat 对象添加一个方法 auth，并将 app.js 中的验证方法粘贴进去</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27; &#x2F;&#x2F;设置为严格模式\n\nconst crypto = require(&#x27;crypto&#x27;); &#x2F;&#x2F;引入加密模块\n\n&#x2F;&#x2F;构建 WeChat 对象 即 js中 函数就是对象\nvar WeChat = function(config){\n    &#x2F;&#x2F;设置 WeChat 对象属性 config\n    this.config = config;\n\n    &#x2F;&#x2F;设置 WeChat 对象属性 token\n    this.token = config.token;\n}\n\n&#x2F;**\n * 微信接入验证\n *&#x2F;\nWeChat.prototype.auth = function(req,res){\n     &#x2F;&#x2F;1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\n        var signature = req.query.signature,&#x2F;&#x2F;微信加密签名\n            timestamp = req.query.timestamp,&#x2F;&#x2F;时间戳\n                nonce = req.query.nonce,&#x2F;&#x2F;随机数\n            echostr = req.query.echostr;&#x2F;&#x2F;随机字符串\n\n        &#x2F;&#x2F;2.将token、timestamp、nonce三个参数进行字典序排序\n        var array = [this.token,timestamp,nonce];\n        array.sort();\n\n        &#x2F;&#x2F;3.将三个参数字符串拼接成一个字符串进行sha1加密\n        var tempStr = array.join(&#x27;&#x27;);\n        const hashCode = crypto.createHash(&#x27;sha1&#x27;); &#x2F;&#x2F;创建加密类型 \n        var resultCode = hashCode.update(tempStr,&#x27;utf8&#x27;).digest(&#x27;hex&#x27;); &#x2F;&#x2F;对传入的字符串进行加密\n\n        &#x2F;&#x2F;4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\n        if(resultCode === signature){\n            res.send(echostr);\n        }else{\n            res.send(&#x27;mismatch&#x27;);\n        }\n}\n\n&#x2F;&#x2F;暴露可供外部访问的接口\nmodule.exports = WeChat;\n</code></pre><p>4.整理 app.js 文件的中的代码，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const express = require(&#x27;express&#x27;), &#x2F;&#x2F;express 框架 \n      wechat  = require(&#x27;.&#x2F;wechat&#x2F;wechat&#x27;), \n       config = require(&#x27;.&#x2F;config&#x27;);&#x2F;&#x2F;引入配置文件\n\nvar app = express();&#x2F;&#x2F;实例express框架\n\nvar wechatApp = new wechat(config); &#x2F;&#x2F;实例wechat 模块\n\n&#x2F;&#x2F;用于处理所有进入 3000 端口 get 的连接请求\napp.get(&#x27;&#x2F;&#x27;,function(req,res){\n    wechatApp.auth(req,res);\n});\n\n&#x2F;&#x2F;监听3000端口\napp.listen(3000);\n</code></pre><p>嗯！这样代码看着是不是舒服多了呢。<img src=\"http://img.blog.csdn.net/20170528144657102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"机智如我\"></p>\n<p>剩下的就是去微信公众平台接入验证了，在<a href=\"http://cnodejs.org/topic/59294bff9e32cc84569a746a\">上一篇文章</a>中有详细的教程，这里我就不再演示了</p>\n<p><img src=\"http://img.blog.csdn.net/20170528145316329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"就是这么懒\"></p>\n<h2>三、access_token的获取、存储及更新</h2>\n<p>1.微信文档步骤</p>\n<p>  在开始码代码之前，我们依然是先理清实现的思路，在开始编写实现代码。打开 <a href=\"https://mp.weixin.qq.com/wiki\">微信帮助文档</a> ，点击左侧菜单中的开始开发，点击其子菜单获取access_token，如图：\n<img src=\"http://img.blog.csdn.net/20170528151333883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"获取access_token\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170529203221439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"获取access_token 帮助文档\"></p>\n<p>通过上面的 API 的描述，我们总结出以下步骤：</p>\n<ol>\n<li>实现 https  Get 请求</li>\n<li>获取 access_token 并存储  如果 当前 access_token 过期则更新</li>\n</ol>\n<p>2.access_token的获取、存储及更新 代码实现</p>\n<p>  整理好思路后我们就按照上一节的步骤去实现。通过帮助文档我们将用于请求微信API 的请求地址与参数，存放到 config.json 文件。</p>\n<p>  其中 appid 与 secret 两个参数 位于  <a href=\"https://mp.weixin.qq.com/\">微信公众平台</a> 左侧菜单的基本配置中，如图：\n<img src=\"http://img.blog.csdn.net/20170527134810969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"微信公众平台 - 基本配置\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170601095037229?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"APPID 与 AppSecret\"></p>\n<p>开发者密码 点击重置，用手机微信扫面二维码后便可得到。config.json 代码如下</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    &quot;token&quot;:&quot;wechat&quot;,\n    &quot;appID&quot;:&quot;wx154f********764da&quot;,\n    &quot;appScrect&quot;:&quot;59de4266*******8dbe9de4b798cd372&quot;,\n    &quot;apiDomain&quot;:&quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;&quot;,\n    &quot;apiURL&quot;:{\n        &quot;accessTokenApi&quot;:&quot;%scgi-bin&#x2F;token?grant_type=client_credential&amp;appid=%s&amp;secret=%s&quot;\n    }\n}\n</code></pre><p>由于微信 API 请求连接的域名是公用的，我们将它提出来，在请求地址中使用 %s(字符串) 占位符占位。</p>\n<p>  微信所有请求连接都是 https 协议，很幸运的是 Node.js 系统包中为我们提供了 https 的包，由于后面的请求会多次用到 https ，因此我们将它封装为一个公用的方法，以便以后的使用，再次打开  wechat.js 在构造方法中，引入 https 模块，并在构造函数内部添加 requestGet 方法</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;用于处理 https Get请求方法\n    this.requestGet = function(url){\n        return new Promise(function(resolve,reject){\n            https.get(url,function(res){\n                var buffer = [],result = &quot;&quot;;\n                &#x2F;&#x2F;监听 data 事件\n                res.on(&#x27;data&#x27;,function(data){\n                    buffer.push(data);\n                });\n                &#x2F;&#x2F;监听 数据传输完成事件\n                res.on(&#x27;end&#x27;,function(){\n                    result = Buffer.concat(buffer,buffer.length).toString(&#x27;utf-8&#x27;);\n                    &#x2F;&#x2F;将最后结果返回\n                    resolve(result);\n                });\n            }).on(&#x27;error&#x27;,function(err){\n                reject(err);\n            });\n        });\n    }\n</code></pre><blockquote>\n<p>提示：</p>\n<p>    npm 提供了很多用于请求的工具包，比如 request ( 安装命令 npm install request ) 等。这里我只是用系统包去做请求处理。</p>\n</blockquote>\n<p>  由于 https 是异步请求的，我在这里面使用了 ES6 的 <a href=\"http://es6.ruanyifeng.com/#docs/promise\">Promise 对象</a> 。</p>\n<p>  完成了 requestGet方法后，我们的第1步骤也就完成了。下面开始第2步，获取 access_token 并存储  如果 当前 access_token 过期则更新。</p>\n<p>  在这之前我是想将 access_token 的存储位置依然放在 config.json 文件中，由于 access_token 在更新后 需要将文件重写，可能容易造成 config.json 文件的格式的紊乱，因此在 wechat 中重新创建一个 accessToken.json 文件用于存储 access_token\n<img src=\"http://img.blog.csdn.net/20170604130201533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    &quot;access_token&quot;:&quot;&quot;,\n    &quot;expires_time&quot;:0\n}\n</code></pre><p>   其中 access_token 用于存储  我们 GET 请求后access_token 的值，expires_time 用于存储 access_token 的过期时间，保存为时间戳。</p>\n<p>  在 wechat.js 引入 fs 模块用于操作文件、util 工具模块用于处理占位符、  accessToken.json 文件</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27; &#x2F;&#x2F;设置为严格模式\n\nconst crypto = require(&#x27;crypto&#x27;), &#x2F;&#x2F;引入加密模块\n       https = require(&#x27;https&#x27;), &#x2F;&#x2F;引入 htts 模块\n        util = require(&#x27;util&#x27;), &#x2F;&#x2F;引入 util 工具包\naccessTokenJson = require(&#x27;.&#x2F;access_token&#x27;); &#x2F;&#x2F;引入本地存储的 access_token\n\n&#x2F;&#x2F;构建 WeChat 对象 即 js中 函数就是对象\nvar WeChat = function(config){\n    &#x2F;&#x2F;设置 WeChat 对象属性 config\n    this.config = config;\n    &#x2F;&#x2F;设置 WeChat 对象属性 token\n    this.token = config.token;\n    &#x2F;&#x2F;设置 WeChat 对象属性 appID\n    this.appID = config.appID;\n    &#x2F;&#x2F;设置 WeChat 对象属性 appScrect\n    this.appScrect = config.appScrect;\n    &#x2F;&#x2F;设置 WeChat 对象属性 apiDomain\n    this.apiDomain = config.apiDomain;\n    &#x2F;&#x2F;设置 WeChat 对象属性 apiURL\n    this.apiDomain = config.apiURL;\n\n    &#x2F;&#x2F;用于处理 https Get请求方法\n    this.requestGet = function(url){\n        return new Promise(function(resolve,reject){\n            https.get(url,function(res){\n                var buffer = [],result = &quot;&quot;;\n                &#x2F;&#x2F;监听 data 事件\n                res.on(&#x27;data&#x27;,function(data){\n                    buffer.push(data);\n                });\n                &#x2F;&#x2F;监听 数据传输完成事件\n                res.on(&#x27;end&#x27;,function(){\n                    result = Buffer.concat(buffer,buffer.length).toString(&#x27;utf-8&#x27;);\n                    &#x2F;&#x2F;将最后结果返回\n                    resolve(result);\n                });\n            }).on(&#x27;error&#x27;,function(err){\n                reject(err);\n            });\n        });\n    }\n}\n</code></pre><p>  在 wechat.js  添加获取 access_token 的方法 getAccessToken</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 获取微信 access_token\n *&#x2F;\nWeChat.prototype.getAccessToken = function(){\n    var that = this;\n    return new Promise(function(resolve,reject){\n        &#x2F;&#x2F;获取当前时间 \n        var currentTime = new Date().getTime();\n        &#x2F;&#x2F;格式化请求地址\n        var url = util.format(that.apiURL.accessTokenApi,that.apiDomain,that.appID,that.appScrect);\n        &#x2F;&#x2F;判断 本地存储的 access_token 是否有效\n        if(accessTokenJson.access_token === &quot;&quot; || accessTokenJson.expires_time &lt; currentTime){\n            that.requestGet(url).then(function(data){\n                var result = JSON.parse(data); \n                if(data.indexOf(&quot;errcode&quot;) &lt; 0){\n                    accessTokenJson.access_token = result.access_token;\n                    accessTokenJson.expires_time = new Date().getTime() + (parseInt(result.expires_in) - 200) * 1000;\n                    &#x2F;&#x2F;更新本地存储的\n                    fs.writeFile(&#x27;.&#x2F;wechat&#x2F;access_token.json&#x27;,JSON.stringify(accessTokenJson));\n                    &#x2F;&#x2F;将获取后的 access_token 返回\n                    resolve(accessTokenJson.access_token);\n                }else{\n                    &#x2F;&#x2F;将错误返回\n                    resolve(result);\n                } \n            });\n        }else{\n            &#x2F;&#x2F;将本地存储的 access_token 返回\n            resolve(accessTokenJson.access_token);  \n        }\n    });\n}\n</code></pre><p>  在 app.js  中添加新的监听链接用于测试 我们获取的token</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;用于请求获取 access_token\napp.get(&#x27;&#x2F;getAccessToken&#x27;,function(req,res){\n    wechatApp.getAccessToken().then(function(data){\n        res.send(data);\n    });    \n});\n</code></pre><p><img src=\"http://img.blog.csdn.net/20170604170244323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"获取access_token的效果图\"></p>\n<p>  这样我们就大功告成了！</p>\n<p><img src=\"http://img.blog.csdn.net/20170604171234743?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"年轻人恭喜你\"></p>\n<p>  文章源代码：<a href=\"https://github.com/SilenceHVK/wechatByNode\">https://github.com/SilenceHVK/wechatByNode</a> 。对文章有不正确之处，请给予纠正。github源代码请顺手给个 Star，最后感谢您的阅读。</p>\n</div>",
    "title": "【Node.js 微信公众号实战】2.Node.js access_token的获取、存储及更新",
    "last_reply_at": "2018-01-29T05:47:24.174Z",
    "good": true,
    "top": false,
    "reply_count": 17,
    "visit_count": 7836,
    "create_at": "2017-06-04T09:21:41.529Z",
    "author": {
        "loginname": "SilenceHVK",
        "avatar_url": "https://avatars3.githubusercontent.com/u/12862565?v=4&s=120"
    }
}, {
    "id": "5a6d777f9d371d4a059eef29",
    "author_id": "56276af03f017c2b49b41575",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>最近在研究大麦的购票流程，中间有个 URL 的跳转实在百思不得其解。\n以这个 URL 为例：&lt;<a href=\"http://www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0\">www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0</a>&gt;\n在浏览器输入后页面会跳转到 <a href=\"https://trade.damai.cn/multi/confirm?***\">https://trade.damai.cn/multi/confirm?***</a> 这样一个页面。\n我直接用 charles 抓包，结果如下：\n<img src=\"//dn-cnode.qbox.me/FuhmJfc3VIN2SEmC-xBtrQPdN14M\" alt=\"1.png\">\n截图框内部分正是最后重定向到的链接。\n但是我用 Node 来模拟请求，想得到请求的页面，始终拿不到，我也尝试获取 302 跳转前的页面：</p>\n<pre class=\"prettyprint language-js\"><code>superagent\n    .get(url)\n    .set(&#x27;Cookie&#x27;, cookie)\n    .redirects(0)\n    .on(&#x27;error&#x27;, err =&gt; {\n      console.log(err.response.text)\n    })\n    .end(function (err, sres) { &#x2F;&#x2F; callback\n    })\n</code></pre><p>我省略了一些请求头，实际上我都带上了，结果如下：\n<img src=\"//dn-cnode.qbox.me/FluRCpPQw7DffageBmoY0iILXGid\" alt=\"2.png\">\n而且我也获取不到最后重定向页面的代码，一直获取的是商品详情页，也就是这个页面 <a href=\"https://piao.damai.cn/141343.html\">https://piao.damai.cn/141343.html</a> 的代码。\n我有两个问题：</p>\n<ol>\n<li>我怎么根据 &lt;<a href=\"http://www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0\">www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0</a>&gt; 获取最后跳转到的页面的 URL（假设有 cookie 等所有请求头信息）</li>\n<li>怎么根据 &lt;<a href=\"http://www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0\">www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0</a>&gt; 获取最后跳转到的页面的 HTML 代码？我将所有头部信息全部填完后模拟请求，一直请求到的是商品详情页也就是这个页面 <a href=\"https://piao.damai.cn/141343.html\">https://piao.damai.cn/141343.html</a> 的代码，不知道哪个环节出了问题</li>\n</ol>\n<p>我用的 HTTP 库是 superagent，望赐教！</p>\n</div>",
    "title": "求分析一个神奇的 HTTP 跳转",
    "last_reply_at": "2018-01-29T05:06:50.792Z",
    "good": false,
    "top": false,
    "reply_count": 7,
    "visit_count": 376,
    "create_at": "2018-01-28T07:10:55.051Z",
    "author": {
        "loginname": "hanzichi",
        "avatar_url": "https://avatars3.githubusercontent.com/u/10890665?v=4&s=120"
    }
}, {
    "id": "5a30c4929807389a1809f352",
    "author_id": "515005e9604b3d512109bb17",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/31966196\">本文</a>首发于知乎专栏<a href=\"https://zhuanlan.zhihu.com/xtech\">蚂蚁金服体验科技</a>。</p>\n</blockquote>\n<p>首先声明，我在“Bug”字眼上加了引号，自然是为了说明它并非一个真 Bug。</p>\n<h2>问题抛出</h2>\n<p>昨天有个童鞋在看后台监控的时候，突然发现了一个错误：</p>\n<pre class=\"prettyprint\"><code>[error] 000001#0: ... upstream prematurely closed connection while reading response header from upstream.\n  client: 10.10.10.10\n  server: foo.com\n  request: &quot;GET &#x2F;foo&#x2F;bar?rmicmd,begin run clean docker images job HTTP&#x2F;1.1&quot;\n  upstream: &quot;http:&#x2F;&#x2F;...&quot;\n</code></pre><p>大概意思就是说：一台服务器通过 HTTP 协议去请求另一台服务器的时候，单方面被对方服务器断开了连接——并且并没有任何返回。</p>\n<h2>开始重现</h2>\n<h3>客户端 CURL 指令</h3>\n<p>其实这次请求的一些猫腻很容易就能发现——在 URL 中有空格。所以我们能简化出一条最简单的 CURL 指令：</p>\n<pre class=\"prettyprint language-sh\"><code>$ curl &quot;http:&#x2F;&#x2F;foo&#x2F;bar baz&quot; -v\n</code></pre><blockquote>\n<p>**注意：**不带任何转义。</p>\n</blockquote>\n<h3>最小 Node.js 源码</h3>\n<p>好的，那么接下去开始写相应的最简单的 Node.js HTTP 服务端源码。</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst http = require(&#x27;http&#x27;);\n\nconst server = http.createServer(function(req, resp) {\n    console.log(&#x27;🌚&#x27;);\n    resp.end(&#x27;hello world&#x27;);\n});\n\nserver.listen(5555);\n</code></pre><p>大功告成，启动这段 Node.js 代码，开始试试看上面的指令吧。</p>\n<p>如果你也正在跟着尝试这件事情的话，你就会发现 Node.js 的命令行没有输出任何信息，尤其是嘲讽的 <code>'🌚'</code>，而在 CURL 的结果中，你将会看见：</p>\n<pre class=\"prettyprint\"><code>$ curl &#x27;http:&#x2F;&#x2F;127.0.0.1:5555&#x2F;d d&#x27; -v\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)\n&gt; GET &#x2F;d d HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5555\n&gt; User-Agent: curl&#x2F;7.54.0\n&gt; Accept: *&#x2F;*\n&gt;\n* Empty reply from server\n* Connection #0 to host 127.0.0.1 left intact\ncurl: (52) Empty reply from server\n</code></pre><p>瞧，<strong>Empty reply from server</strong>。</p>\n<h3>Nginx</h3>\n<p>发现了问题之后，就有另一个问题值得思考了：就 Node.js 会出现这种情况呢，还是其它一些 HTTP 服务器也会有这种情况呢。</p>\n<p>于是拿小白鼠 Nginx 做了个实验。我写了这么一个配置：</p>\n<pre class=\"prettyprint language-nginx\"><code>server {\n    listen 5555;\n\n    location &#x2F; {\n        return 200 $uri;\n    }\n}\n</code></pre><p>接着也执行一遍 CURL，得到了如下的结果：</p>\n<pre class=\"prettyprint\"><code>$ curl &#x27;http:&#x2F;&#x2F;127.0.0.1:5555&#x2F;d d&#x27; -v\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)\n&gt; GET &#x2F;d d HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5555\n&gt; User-Agent: curl&#x2F;7.54.0\n&gt; Accept: *&#x2F;*\n&gt;\n&lt; HTTP&#x2F;1.1 200 OK\n&lt; Server: openresty&#x2F;1.11.2.1\n&lt; Date: Tue, 12 Dec 2017 09:07:56 GMT\n&lt; Content-Type: application&#x2F;octet-stream\n&lt; Content-Length: 4\n&lt; Connection: keep-alive\n&lt;\n* Connection #0 to host xcoder.in left intact\n&#x2F;d d\n</code></pre><p><img src=\"http://ww2.sinaimg.cn/bmiddle/a15b4afegy1fmf43teykfj20c80c8ta0\" alt=\"厉害了，我的 Nginx\"></p>\n<p>于是乎，理所当然，我<strong>暂时</strong>将这个事件定性为 Node.js 的一个 Bug。</p>\n<h2>Node.js 源码排查</h2>\n<p>认定了它是个 Bug 之后，我就开始了一贯的看源码环节——由于这个 Bug 的复现条件比较明显，我暂时将其定性为“Node.js HTTP 服务端模块在接到请求后解析 HTTP 数据包的时候解析 URI 时出了问题”。</p>\n<h3>http.js -&gt; _http_server.js -&gt; _http_common.js</h3>\n<blockquote>\n<p>源码以 <a href=\"https://github.com/nodejs/node/tree/v8.9.2\">Node.js 8.9.2</a> 为准。</p>\n</blockquote>\n<p>这里先预留一下我们能马上想到的 <strong>node_http_parser.cc</strong>，而先讲这几个文件，是有原因的——这涉及到最后的一个应对方式。</p>\n<p>首先看看 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/lib/http.js#L33-L35\"><strong>lib/http.js</strong></a> 的相应源码：</p>\n<pre class=\"prettyprint language-js\"><code>...\nconst server = require(&#x27;_http_server&#x27;);\n\nconst { Server } = server;\n\nfunction createServer(requestListener) {\n  return new Server(requestListener);\n}\n</code></pre><p>那么，马上进入 <strong>lib/_http_server.js</strong> 看吧。</p>\n<p>首先是创建一个 HttpParser 并绑上监听获取到 HTTP 数据包后解析结果的回调函数的代码：</p>\n<pre class=\"prettyprint language-js\"><code>const {\n  parsers,\n  ...\n} = require(&#x27;_http_common&#x27;);\n\nfunction connectionListener(socket) {\n  ...\n\n  var parser = parsers.alloc();\n  parser.reinitialize(HTTPParser.REQUEST);\n  parser.socket = socket;\n  socket.parser = parser;\n  parser.incoming = null;\n\n  ...\n\n  state.onData = socketOnData.bind(undefined, this, socket, parser, state);\n  ...\n  socket.on(&#x27;data&#x27;, state.onData);\n\n  ...\n}\n\nfunction socketOnData(server, socket, parser, state, d) {\n  assert(!socket._paused);\n  debug(&#x27;SERVER socketOnData %d&#x27;, d.length);\n\n  var ret = parser.execute(d);\n  onParserExecuteCommon(server, socket, parser, state, ret, d);\n}\n</code></pre><p>从源码中文我们能看到，当一个 HTTP 请求过来的时候，监听函数 <code>connectionListener()</code> 会拿着 Socket 对象加上一个 <code>data</code> 事件监听——一旦有请求连接过来，就去执行 <code>socketOnData()</code> 函数。</p>\n<p>而在 <code>socketOnData()</code> 函数中，做的主要事情就是 <code>parser.execute(d)</code> 来解析 HTTP 数据包，在解析完成后执行一下回调函数 <code>onParserExecuteCommon()</code>。</p>\n<p>至于这个 <code>parser</code>，我们能看到它是从 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/lib/_http_common.js#L170-L193\"><strong>lib/_http_common.js</strong></a> 中来的。</p>\n<pre class=\"prettyprint language-js\"><code>var parsers = new FreeList(&#x27;parsers&#x27;, 1000, function() {\n  var parser = new HTTPParser(HTTPParser.REQUEST);\n\n  ...\n\n  parser[kOnHeaders] = parserOnHeaders;\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\n  parser[kOnBody] = parserOnBody;\n  parser[kOnMessageComplete] = parserOnMessageComplete;\n  parser[kOnExecute] = null;\n\n  return parser;\n});\n</code></pre><p>能看出来 <code>parsers</code> 是 <code>HTTPParser</code> 的一条 Free List（效果类似于最简易的动态内存池），每个 Parser 在初始化的时候绑定上了各种回调函数。具体的一些回调函数就不细讲了，有兴趣的童鞋可自行翻阅。</p>\n<p>这么一来，链路就比较明晰了：</p>\n<p><strong>请求进来的时候，Server 对象会为该次请求的 Socket 分配一个 <code>HttpParser</code> 对象，并调用其 <code>execute()</code> 函数进行解析，在解析完成后调用 <code>onParserExecuteCommon()</code> 函数。</strong></p>\n<h3>node_http_parser.cc</h3>\n<p>我们在 <strong>lib/_http_common.js</strong> 中能发现，<code>HTTPParser</code> 的实现存在于 <strong>src/node_http_parser.cc</strong> 中：</p>\n<pre class=\"prettyprint language-js\"><code>const binding = process.binding(&#x27;http_parser&#x27;);\nconst { methods, HTTPParser } = binding;\n</code></pre><blockquote>\n<p>至于为什么 <code>const binding = process.binding('http_parser')</code> 就是对应到 <strong>src/node_http_parser.cc</strong> 文件，以及这一小节中下面的一些 C++ 源码相关分析，不明白且有兴趣的童鞋可自行去阅读更深一层的源码，或者网上搜索答案，或者我提前无耻硬广一下我快要上市的书《Node.js：来一打 C++ 扩展》——里面也有说明，以及我的有一场知乎 Live《深入理解 Node.js 包与模块机制》。</p>\n</blockquote>\n<p>总而言之，我们接下去要看的就是 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/src/node_http_parser.cc#L796-L804\"><strong>src/node_http_parser.cc</strong></a> 了。</p>\n<pre class=\"prettyprint language-cpp\"><code>env-&gt;SetProtoMethod(t, &quot;close&quot;, Parser::Close);\nenv-&gt;SetProtoMethod(t, &quot;execute&quot;, Parser::Execute);\nenv-&gt;SetProtoMethod(t, &quot;finish&quot;, Parser::Finish);\nenv-&gt;SetProtoMethod(t, &quot;reinitialize&quot;, Parser::Reinitialize);\nenv-&gt;SetProtoMethod(t, &quot;pause&quot;, Parser::Pause&lt;true&gt;);\nenv-&gt;SetProtoMethod(t, &quot;resume&quot;, Parser::Pause&lt;false&gt;);\nenv-&gt;SetProtoMethod(t, &quot;consume&quot;, Parser::Consume);\nenv-&gt;SetProtoMethod(t, &quot;unconsume&quot;, Parser::Unconsume);\nenv-&gt;SetProtoMethod(t, &quot;getCurrentBuffer&quot;, Parser::GetCurrentBuffer);\n</code></pre><p>如代码片段所示，前文中 <code>parser.execute()</code> 所对应的函数就是 <code>Parser::Execute()</code> 了。</p>\n<pre class=\"prettyprint language-cpp\"><code>class Parser : public AsyncWrap {\n  ...\n\n  static void Execute(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n    Parser* parser;\n    ...\n\n    Local&lt;Object&gt; buffer_obj = args[0].As&lt;Object&gt;();\n    char* buffer_data = Buffer::Data(buffer_obj);\n    size_t buffer_len = Buffer::Length(buffer_obj);\n\n    ...\n\n    Local&lt;Value&gt; ret = parser-&gt;Execute(buffer_data, buffer_len);\n\n    if (!ret.IsEmpty())\n      args.GetReturnValue().Set(ret);\n  }\n\n  Local&lt;Value&gt; Execute(char* data, size_t len) {\n    EscapableHandleScope scope(env()-&gt;isolate());\n\n    current_buffer_len_ = len;\n    current_buffer_data_ = data;\n    got_exception_ = false;\n\n    size_t nparsed =\n      http_parser_execute(&amp;parser_, &amp;settings, data, len);\n\n    Save();\n\n    &#x2F;&#x2F; Unassign the &#x27;buffer_&#x27; variable\n    current_buffer_.Clear();\n    current_buffer_len_ = 0;\n    current_buffer_data_ = nullptr;\n\n    &#x2F;&#x2F; If there was an exception in one of the callbacks\n    if (got_exception_)\n      return scope.Escape(Local&lt;Value&gt;());\n\n    Local&lt;Integer&gt; nparsed_obj = Integer::New(env()-&gt;isolate(), nparsed);\n    &#x2F;&#x2F; If there was a parse error in one of the callbacks\n    &#x2F;&#x2F; TODO(bnoordhuis) What if there is an error on EOF?\n    if (!parser_.upgrade &amp;&amp; nparsed != len) {\n      enum http_errno err = HTTP_PARSER_ERRNO(&amp;parser_);\n\n      Local&lt;Value&gt; e = Exception::Error(env()-&gt;parse_error_string());\n      Local&lt;Object&gt; obj = e-&gt;ToObject(env()-&gt;isolate());\n      obj-&gt;Set(env()-&gt;bytes_parsed_string(), nparsed_obj);\n      obj-&gt;Set(env()-&gt;code_string(),\n               OneByteString(env()-&gt;isolate(), http_errno_name(err)));\n\n      return scope.Escape(e);\n    }\n    return scope.Escape(nparsed_obj);\n  }\n}\n</code></pre><p>首先进入 <code>Parser</code> 的静态 <code>Execute()</code> 函数，我们看到它把传进来的 <code>Buffer</code> 转化为 C++ 下的 <code>char*</code> 指针，并记录其数据长度，同时去执行当前调用的 <code>parser</code> 对象所对应的 <code>Execute()</code> 函数。</p>\n<p>在这个 <code>Execute()</code> 函数中，有个最重要的代码，就是：</p>\n<pre class=\"prettyprint language-cpp\"><code>size_t nparsed =\n    http_parser_execute(&amp;parser_, &amp;settings, data, len);\n</code></pre><p>这段代码是调用真正解析 HTTP 数据包的函数，它是 Node.js 这个项目的一个自研依赖，叫 <a href=\"https://github.com/nodejs/node/tree/v8.9.2/deps/http_parser\">http-parser</a>。它独立的项目地址在 <a href=\"https://github.com/nodejs/http-parser\">https://github.com/nodejs/http-parser</a>，我们本文中用的是 Node.js v8.9.2 中所依赖的源码，应该会有偏差。</p>\n<h3>http-parser</h3>\n<h4>HTTP Request 数据包体</h4>\n<blockquote>\n<p>如果你已经对 HTTP 包体了解了，可以略过这一节。</p>\n</blockquote>\n<p>HTTP 的 Request 数据包其实是文本格式的，在 Raw 的状态下，大概是以这样的形式存在：</p>\n<pre class=\"prettyprint\"><code>方法 URI HTTP&#x2F;版本\n头1: 我是头1\n头2: 我是头2\n</code></pre><blockquote>\n<p>简单起见，这里就写出最基础的一些内容，至于 Body 什么的大家自己找资料看吧。</p>\n</blockquote>\n<p>上面的是什么意思呢？我们看看 CURL 的结果就知道了，实际上对应 <code>curl ... -v</code> 的中间输出：</p>\n<pre class=\"prettyprint\"><code>GET &#x2F;test HTTP&#x2F;1.1\nHost: 127.0.0.1:5555\nUser-Agent: curl&#x2F;7.54.0\nAccept: *&#x2F;*\n</code></pre><p>所以实际上大家平时在文章中、浏览器调试工具中看到的什么请求头啊什么的，都是以文本形式存在的，以换行符分割。</p>\n<p>而——重点来了，导致我们本文所述“Bug”出现的请求，它的请求包如下：</p>\n<pre class=\"prettyprint\"><code>GET &#x2F;foo bar HTTP&#x2F;1.1\nHost: 127.0.0.1:5555\nUser-Agent: curl&#x2F;7.54.0\nAccept: *&#x2F;*\n</code></pre><p>重点在第一行：</p>\n<pre class=\"prettyprint\"><code>GET &#x2F;foo bar HTTP&#x2F;1.1\n</code></pre><h4>源码解析</h4>\n<p>话不多少，我们之间前往 http-parser 的 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/deps/http_parser/http_parser.c#L634\">http_parser.c</a> 看 <code>http_parser_execute ()</code> 函数中的状态机变化。</p>\n<p>从源码中文我们能看到，http-parser 的流程是从头到尾以 O(n) 的时间复杂度对字符串逐字扫描，并且不后退也不往前跳。</p>\n<p>那么扫描到每个字符的时候，都有属于当前的一个状态，如“正在扫描处理 uri”、“正在扫描处理 HTTP 协议并且处理到了 H”、“正在扫描处理 HTTP 协议并且处理到了 HT”、“正在扫描处理 HTTP 协议并且处理到了 HTT”、“正在扫描处理 HTTP 协议并且处理到了 HTTP”、……</p>\n<p><img src=\"http://ww2.sinaimg.cn/bmiddle/a15b4afegy1fmf459xnmvj208c05w762\" alt=\"这是回音你懂吗\"></p>\n<p>憋笑，这是真的，我们看看代码就知道了：</p>\n<pre class=\"prettyprint language-c\"><code>case s_req_server:\ncase s_req_server_with_at:\ncase s_req_path:\ncase s_req_query_string_start:\ncase s_req_query_string:\ncase s_req_fragment_start:\ncase s_req_fragment:\n{\n  switch (ch) {\n    case &#x27; &#x27;:\n      UPDATE_STATE(s_req_http_start);\n      CALLBACK_DATA(url);\n      break;\n    case CR:\n    case LF:\n      parser-&gt;http_major = 0;\n      parser-&gt;http_minor = 9;\n      UPDATE_STATE((ch == CR) ?\n        s_req_line_almost_done :\n        s_header_field_start);\n      CALLBACK_DATA(url);\n      break;\n    default:\n      UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));\n      if (UNLIKELY(CURRENT_STATE() == s_dead)) {\n        SET_ERRNO(HPE_INVALID_URL);\n        goto error;\n      }\n  }\n  break;\n}\n</code></pre><p>在扫描的时候，如果当前状态是 URI 相关的（如 <code>s_req_path</code>、<code>s_req_query_string</code> 等），则执行一个子 <code>switch</code>，里面的处理如下：</p>\n<ul>\n<li>若当前字符是空格，则将状态改变为 <code>s_req_http_start</code> 并认为 URI 已经解析好了，通过宏 <code>CALLBACK_DATA()</code> 触发 URI 解析好的事件；</li>\n<li>若当前字符是换行符，则说明还在解析 URI 的时候就被换行了，后面就不可能跟着 HTTP 协议版本的申明了，所以设置默认的 HTTP 版本为 <code>0.9</code>，并修改当前状态，最后认为 URI 已经解析好了，通过宏 <code>CALLBACK_DATA()</code> 触发 URI 解析好的事件；</li>\n<li>其余情况（所有其它字符）下，通过调用 <code>parse_url_char()</code> 函数来解析一些东西并更新当前状态。（因为哪怕是在解析 URI 状态中，也还有各种不同的细分，如 <code>s_req_path</code>、<code>s_req_query_string</code> ）</li>\n</ul>\n<p>这里的重点还是当状态为解析 URI 的时候遇到了空格的处理，上面也解释过了，一旦遇到这种情况，则会认为 URI 已经解析好了，并且将状态修改为 <code>s_req_http_start</code>。也就是说，有“Bug”的那个数据包\n<code>GET /foo bar HTTP/1.1</code> 在解析到 <code>foo</code> 后面的空格的时候它就将状态改为 <code>s_req_http_start</code> 并且认为 URI 已经解析结束了。</p>\n<p>好的，接下来我们看看 <code>s_req_http_start</code> 怎么处理：</p>\n<pre class=\"prettyprint language-c\"><code>case s_req_http_start:\n  switch (ch) {\n    case &#x27;H&#x27;:\n      UPDATE_STATE(s_req_http_H);\n      break;\n    case &#x27; &#x27;:\n      break;\n    default:\n      SET_ERRNO(HPE_INVALID_CONSTANT);\n      goto error;\n  }\n  break;\n\ncase s_req_http_H:\n  STRICT_CHECK(ch != &#x27;T&#x27;);\n  UPDATE_STATE(s_req_http_HT);\n  break;\n\ncase s_req_http_HT:\n  ...\n\ncase s_req_http_HTT:\n  ...\n\ncase s_req_http_HTTP:\n  ...\n\ncase s_req_first_http_major:\n  ...\n</code></pre><p>如代码所见，若当前状态为 <code>s_req_http_start</code>，则先判断当前字符是不是合标。因为就 HTTP 请求包体的格式来看，如果 URI 解析结束的话，理应出现类似 <code>HTTP/1.1</code> 的这么一个版本申明。所以这个时候 http-parser 会直接判断当前字符是否为 <code>H</code>。</p>\n<ul>\n<li>若是 <code>H</code>，则将状态改为 <code>s_req_http_H</code> 并继续扫描循环的下一位，同理在 <code>s_req_http_H</code> 下若合法状态就会变成 <code>s_req_http_HT</code>，以此类推；\n+若是空格，则认为是多余的空格，那么当前状态不做任何改变，并继续下一个扫描；</li>\n<li>但如果当前字符既不是空格也不是 <code>H</code>，那么好了，http-parser 直接认为你的请求包不合法，将你本次的解析设置错误 <code>HPE_INVALID_CONSTANT</code> 并 <code>goto</code> 到 <code>error</code> 代码块。</li>\n</ul>\n<p>至此，我们基本上已经明白了原因了：</p>\n<p><strong>http-parser 认为在 HTTP 请求包体中，第一行的 URI 解析阶段一旦出现了空格，就会认为 URI 解析完成，继而解析 HTTP 协议版本。但若此时紧跟着的不是 HTTP 协议版本的标准格式，http-parser 就会认为你这是一个 <code>HPE_INVALID_CONSTANT</code> 的数据包。</strong></p>\n<p>不过，我们还是继续看看它的 <code>error</code> 代码块吧：</p>\n<pre class=\"prettyprint language-c\"><code>error:\n  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {\n    SET_ERRNO(HPE_UNKNOWN);\n  }\n\n  RETURN(p - data);\n</code></pre><p>这段代码中首先判断一下当跳到这段代码的时候有没有设置错误，若没有设置错误则将错误设置为未知错误（<code>HPE_UNKNOWN</code>），然后返回已解析的数据包长度。</p>\n<blockquote>\n<p><code>p</code> 是当前解析字符指针，<code>data</code> 是这个数据包的起始指针，所以 <code>p - data</code> 就是已解析的数据长度。如果成功解析完，这个数据包理论上是等于这个数据包的完整长度，若不等则理论上说明肯定是中途出错提前返回。</p>\n</blockquote>\n<h3>回到 node_http_parser.cc</h3>\n<p>看完了 http-parser 的原理后，很多地方茅塞顿开。现在我们回到它的调用地 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/src/node_http_parser.cc#L630-L666\"><strong>node_http_parser.cc</strong></a> 继续阅读吧。</p>\n<pre class=\"prettyprint language-cpp\"><code>Local&lt;Value&gt; Execute(char* data, size_t len) {\n  ...\n\n  size_t nparsed =\n    http_parser_execute(&amp;parser_, &amp;settings, data, len);\n\n  Local&lt;Integer&gt; nparsed_obj = Integer::New(env()-&gt;isolate(), nparsed);\n  if (!parser_.upgrade &amp;&amp; nparsed != len) {\n    enum http_errno err = HTTP_PARSER_ERRNO(&amp;parser_);\n\n    Local&lt;Value&gt; e = Exception::Error(env()-&gt;parse_error_string());\n    Local&lt;Object&gt; obj = e-&gt;ToObject(env()-&gt;isolate());\n    obj-&gt;Set(env()-&gt;bytes_parsed_string(), nparsed_obj);\n    obj-&gt;Set(env()-&gt;code_string(),\n             OneByteString(env()-&gt;isolate(), http_errno_name(err)));\n\n    return scope.Escape(e);\n  }\n  return scope.Escape(nparsed_obj);\n}\n</code></pre><p>从调用处我们能看见，在执行完 <code>http_parser_execute()</code> 后有一个判断，若当前请求不是 <code>upgrade</code> 请求（即请求头中有说明 <code>Upgrade</code>，通常用于 WebSocket），并且解析长度不等于原数据包长度（前文说了这种情况属于出错了）的话，那么进入中间的错误代码块。</p>\n<p>在错误代码块中，先 <code>HTTP_PARSER_ERRNO(&amp;parser_)</code> 拿到错误码，然后通过 <code>Exception::Error()</code> 生成错误对象，将错误信息塞进错误对象中，最后返回错误对象。</p>\n<p>如果没错，则返回解析长度（<code>nparsed_obj</code> 即 <code>nparsed</code>）。</p>\n<blockquote>\n<p>在这个文件中，眼尖的童鞋可能发现了，执行 <code>Execute()</code> 有好多处，这是因为实际上一个 HTTP 请求可能是流式的，所以有时候可能会只拿到部分数据包。所以最后有一个结束符需要被确认。<strong>这也是为什么 http-parser 在解析的时候只能逐字解析而不能跳跃或者后退了。</strong></p>\n</blockquote>\n<h3>回到 _http_server.js</h3>\n<p>我们把 <code>Parser::Execute()</code> 也就是 JavaScript 代码中的 <code>parser.execute()</code> 给搞清楚后，我们就能回到 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/lib/_http_server.js#L462-L507\">_http_server.js</a> 看代码了。</p>\n<p>前文说了，<code>socketOnData</code> 在解析完数据包后会执行 <code>onParserExecuteCommon</code> 函数，现在就来看看这个 <code>onParserExecuteCommon()</code> 函数。</p>\n<pre class=\"prettyprint language-js\"><code>function onParserExecuteCommon(server, socket, parser, state, ret, d) {\n  resetSocketTimeout(server, socket, state);\n\n  if (ret instanceof Error) {\n    debug(&#x27;parse error&#x27;, ret);\n    socketOnError.call(socket, ret);\n  } else if (parser.incoming &amp;&amp; parser.incoming.upgrade) {\n    ...\n  }\n}\n</code></pre><p>长长的一个函数被我精简成这么几句话，重点很明显。<code>ret</code> 就是从 <code>socketOnData</code> 传进来已解析的数据长度，但是在 C++ 代码中我们也看到了它还有可能是一个错误对象。所以在这个函数中一开始就做了一个判断，判断解析的结果是不是一个错误对象，如果是错误对象则调用 <code>socketOnError()</code>。</p>\n<pre class=\"prettyprint language-js\"><code>function socketOnError(e) {\n  &#x2F;&#x2F; Ignore further errors\n  this.removeListener(&#x27;error&#x27;, socketOnError);\n  this.on(&#x27;error&#x27;, () =&gt; {});\n\n  if (!this.server.emit(&#x27;clientError&#x27;, e, this))\n    this.destroy(e);\n}\n</code></pre><p>我们看到，如果真的不小心走到这一步的话，HTTP Server 对象会触发一个 <code>clientError</code> 事件。</p>\n<p>整个事情串联起来了：</p>\n<ul>\n<li>收到请求后会通过 http-parser 解析数据包；</li>\n<li><code>GET /foo bar HTTP/1.1</code> 会被解析出错并返回一个错误对象；</li>\n<li>错误对象会进入 <code>if (ret instanceof Error)</code> 条件分支并调用 <code>socketOnError()</code> 函数；</li>\n<li><code>socketOnError()</code> 函数中会对服务器触发一个 <code>clientError</code> 事件；（<code>this.server.emit('clientError', e, this)</code>）</li>\n<li><strong>至此，HTTP Server 并不会走到你的那个 <code>function(req, resp)</code> 中去，所以不会有任何的数据被返回就结束了，也就解答了一开始的问题——收不到任何数据就请求结束。</strong></li>\n</ul>\n<p>这就是我要逐级进来看代码，而不是直达 http-parser 的原因了——<code>clientError</code> 是一个关键。</p>\n<h2>处理办法</h2>\n<p>要解决这个“Bug”其实不难，直接监听 <a href=\"https://nodejs.org/api/http.html#http_event_clienterror\"><code>clientError</code> 事件</a>并做一些处理即可。</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst http = require(&#x27;http&#x27;);\n\nconst server = http.createServer(function(req, resp) {\n    console.log(&#x27;🌚&#x27;);\n    resp.end(&#x27;hello world&#x27;);\n}).on(&#x27;clientError&#x27;, function(err, sock) {\n    console.log(&#x27;🐷&#x27;);\n    sock.end(&#x27;HTTP&#x2F;1.1 400 Bad Request\\r\\n\\r\\n&#x27;);\n});\n\nserver.listen(5555);\n</code></pre><blockquote>\n<p>**注意：**由于运行到 <code>clientError</code> 事件时，并没有任何 Request 和 Response 的封装，你能拿到的是一个 Node.js 中原始的 Socket 对象，所以当你要返回数据的时候需要自己按照 HTTP 返回数据包的格式来输出。</p>\n</blockquote>\n<p>这个时候再挥起你的小手试一下 CURL 吧：</p>\n<pre class=\"prettyprint\"><code>$ curl &#x27;http:&#x2F;&#x2F;127.0.0.1:5555&#x2F;d d&#x27; -v\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)\n&gt; GET &#x2F;d d HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5555\n&gt; User-Agent: curl&#x2F;7.54.0\n&gt; Accept: *&#x2F;*\n&gt;\n&lt; HTTP&#x2F;1.1 400 Bad Request\n* no chunk, no close, no size. Assume close to signal end\n&lt;\n* Closing connection 0\n</code></pre><p>如愿以偿地输出了 400 状态码。</p>\n<h2>引申</h2>\n<p>接下来我们要引申讨论的一个点是，为什么这货不是一个真正意义上的 Bug。</p>\n<p>首先我们看看 Nginx 这么实现这个黑科技的吧。</p>\n<h3>Nginx 实现</h3>\n<p>打开 Nginx 源码的<a href=\"https://github.com/nginx/nginx/blob/release-1.13.7/src/http/ngx_http_parse.c#L104\">相应位置</a>。</p>\n<p>我们能看到它的状态机对于 URI 和 HTTP 协议声明中间多了一个中间状态，叫 <code>sw_check_uri_http_09</code>，专门处理 URI 后面的空格。</p>\n<p>在各种 URI 解析状态中，基本上都能找到这么一句话，表示若当前状态正则解析 URI 的各种状态并且遇到空格的话，则将状态改为 <code>sw_check_uri_http_09</code>。</p>\n<pre class=\"prettyprint language-c\"><code>case sw_check_uri:\n  switch (ch) {\n  case &#x27; &#x27;:\n    r-&gt;uri_end = p;\n    state = sw_check_uri_http_09;\n    break;\n\n  ...\n  }\n\n  ...\n</code></pre><p>然后在 <code>sw_check_uri_http_09</code> 状态时会做一些检查：</p>\n<pre class=\"prettyprint language-c\"><code>case sw_check_uri_http_09:\n    switch (ch) {\n    case &#x27; &#x27;:\n        break;\n    case CR:\n        r-&gt;http_minor = 9;\n        state = sw_almost_done;\n        break;\n    case LF:\n        r-&gt;http_minor = 9;\n        goto done;\n    case &#x27;H&#x27;:\n        r-&gt;http_protocol.data = p;\n        state = sw_http_H;\n        break;\n    default:\n        r-&gt;space_in_uri = 1;\n        state = sw_check_uri;\n        p--;\n        break;\n    }\n    break;\n</code></pre><p>例如：</p>\n<ul>\n<li>遇到空格则继续保持当前状态开始扫描下一位；</li>\n<li>如果是换行符则设置默认 HTTP 版本并继续扫描；</li>\n<li>如果遇到的是 <code>H</code> 才修改状态为 <code>sw_http_H</code> 认为接下去开始 HTTP 版本扫描；</li>\n<li>如果是其它字符，则标明一下 URI 中有空格，然后将状态改回 <code>sw_check_uri</code>，然后倒退回一格以 <code>sw_check_uri</code> 继续扫描当前的空格。</li>\n</ul>\n<p>在理解了这个“黑科技”后，我们很快能找到一个很好玩的点，开启你的 Nginx 并用 CURL 请求以下面的例子一下它看看吧：</p>\n<pre class=\"prettyprint\"><code>$ curl &#x27;http:&#x2F;&#x2F;xcoder.in:5555&#x2F;d H&#x27; -v\n*   Trying 103.238.225.181...\n* TCP_NODELAY set\n* Connected to xcoder.in (103.238.225.181) port 5555 (#0)\n&gt; GET &#x2F;d H HTTP&#x2F;1.1\n&gt; Host: xcoder.in:5555\n&gt; User-Agent: curl&#x2F;7.54.0\n&gt; Accept: *&#x2F;*\n&gt;\n&lt; HTTP&#x2F;1.1 400 Bad Request\n&lt; Server: openresty&#x2F;1.11.2.1\n&lt; Date: Tue, 12 Dec 2017 11:18:13 GMT\n&lt; Content-Type: text&#x2F;html\n&lt; Content-Length: 179\n&lt; Connection: close\n&lt;\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;400 Bad Request&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;\n&lt;body bgcolor=&quot;white&quot;&gt;\n&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;\n&lt;hr&gt;&lt;center&gt;openresty&#x2F;1.11.2.1&lt;&#x2F;center&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n* Closing connection 0\n</code></pre><p>怎么样？是不是发现结果跟之前的不一样了——它居然也返回了 400 Bad Request。</p>\n<p>原因为何就交给童鞋们自己考虑吧。</p>\n<h3>RFC 2616 与 RFC 2396</h3>\n<p>那么，为什么即使在 Nginx 支持空格 URI 的情况下，我还说 Node.js 这个不算 Bug，并且指明 Nginx 是“黑科技”呢？</p>\n<p>后来我去看了 HTTP 协议 RFC。</p>\n<p>原因在于 Network Working Group 的 <a href=\"http://www.ietf.org/rfc/rfc2616.txt\">RFC 2616</a>，关于 HTTP 协议的规范。</p>\n<p>在 RFC 2616 的 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.1\">3.2.1 节</a>中做了一些说明，它说了在 HTTP 协议中关于 URI 的文法和语义参照了 <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a>。</p>\n<blockquote>\n<p>URIs in HTTP can be represented in absolute form or relative to some known base URI, depending upon the context of their use. The two forms are differentiated by the fact that absolute URIs always begin with a scheme name followed by a colon. For definitive information on URL syntax and semantics, see “Uniform Resource Identifiers (URI): Generic Syntax and Semantics,” RFC 2396 (which replaces RFCs 1738 and RFC 1808). This specification adopts the definitions of “URI-reference”, “absoluteURI”, “relativeURI”, “port”, “host”,“abs_path”, “rel_path”, and “authority” from that specification.</p>\n</blockquote>\n<p>而在 <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a> 中，我们同样找到了它的 <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">2.4.3 节</a>。里面对于 Disallow 的 US-ASCII 字符做了解释，其中有：</p>\n<ul>\n<li>\n<p>控制符，指 ASCII 码在 0x00-0x1F 范围内以及 0x7F；</p>\n<p>控制符通常不可见；</p>\n</li>\n<li>\n<p>空格，指 0x20；</p>\n<p>空格不可控，如经由一些排版软件转录后可能会有变化，&lt;span style=“color: #ccc;”&gt;而到了 HTTP 协议这层时，反正空格不推荐使用了，所以就索性用空格作为首行分隔符了；&lt;/span&gt;</p>\n</li>\n<li>\n<p>分隔符，<code>&quot;&lt;&quot;</code>、<code>&quot;&gt;&quot;</code>、<code>&quot;#&quot;</code>、<code>&quot;%&quot;</code>、<code>&quot;\\&quot;&quot;</code>。</p>\n<p>如 <code>#</code> 将用于浏览器地址栏的 Hash；而 <code>%</code> 则会与 URI 转义一同使用，所以不应单独出现在 URI 中。</p>\n</li>\n</ul>\n<p><strong>于是乎，HTTP 请求中，包体的 URI 似乎本就不应该出现空格，而 Nginx 是一个黑魔法的姿势。</strong></p>\n<h2>小结</h2>\n<p>嚯，写得累死了。本次的一个探索基于了一个有空格非正常的 URI 通过 CURL 或者其它一些客户端请求时，Node.js 出现的 Bug 状态。</p>\n<blockquote>\n<p>实际上发现这个 Bug 的时候，客户端请求似乎是因为那边的开发者手抖，不小心将不应该拼接进来的内容给拼接到了 URL 中，类似于 <code>$ rm -rf /</code>。</p>\n</blockquote>\n<p>一开始我以为这是 Node.js 的 Bug，在探寻之后发现是因为我们自己没用 Node.js HTTP Server 提供的 <code>clientError</code> 事件做正确的处理。而 Nginx 的正常请求则是它的黑科技。这些答案都能从 RFC 中寻找——<strong>再次体现了遇到问题看源码看规范的重要性。</strong></p>\n<p>另，我本打算给 http-parser 也加上黑魔法，后来我快写好的时候发现它是流式的，很多状态没法在现有的体系中保留下来，最后放弃了，反正这也不算 Bug。不过在以后有时间的时候，感觉还是可以好好整理一下代码，好好修改一下给提个 PR 上去，以此自勉。</p>\n<p>最后，求 fafa。</p>\n<p><img src=\"http://ww2.sinaimg.cn/bmiddle/a15b4afely1fme81d41wpg206o06oabl\" alt=\"求 fafa\"></p>\n<h2>交流</h2>\n<p>如果你有更多的想法，或者想了解蚂蚁金服的 Node.js、前端以及设计小伙伴们的更多姿势，可以报名首届蚂蚁体验科技大会 SEE Conf，比如有死马大大的《Developer Experience First —— Techless Web Application 的理念与实践》，还有青栀大大的《蚂蚁开发者工具，服务蚂蚁生态的移动研发 IDE》等等。</p>\n<p>报名官网：<a href=\"https://seeconf.alipay.com/\">https://seeconf.alipay.com/</a></p>\n<p>期待您的光临。</p>\n</div>",
    "title": "Node.js 中遇到含空格 URL 的神奇“Bug”——小范围深入 HTTP 协议",
    "last_reply_at": "2018-01-29T02:52:14.077Z",
    "good": true,
    "top": false,
    "reply_count": 23,
    "visit_count": 2479,
    "create_at": "2017-12-13T06:11:30.129Z",
    "author": {
        "loginname": "xadillax",
        "avatar_url": "https://avatars3.githubusercontent.com/u/2842176?v=4&s=120"
    }
}, {
    "id": "5a6ae0b99288dc815328826a",
    "author_id": "5775bd840b982e0450b7463e",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>我需要在vue项目运行时引入新的vue文件，该文件是服务器生成的通过ajax请求回去的，请问如何实现这个功能？</p>\n</div>",
    "title": "vue这么动态引入vue文件？",
    "last_reply_at": "2018-01-29T02:20:33.363Z",
    "good": false,
    "top": false,
    "reply_count": 4,
    "visit_count": 370,
    "create_at": "2018-01-26T08:03:05.836Z",
    "author": {
        "loginname": "mcck",
        "avatar_url": "https://avatars.githubusercontent.com/u/20223048?v=3&s=120"
    }
}, {
    "id": "5a6b566e9d371d4a059eeef1",
    "author_id": "59413aaa8ce045ee166a1544",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>就在最近，我完成了Parse JavaScript SDK指南的翻译，并在指南中加入了一些教程、示例，以保证新手能够快速上手。</p>\n<p>我在QQ群里面贴出<a href=\"https://parse-zh.buzhundong.com/\">地址</a>宣传了下，然后发现大部分人听都没听说过Parse，果然，我是站在潮流之巅的弄潮儿啊hhhhhh~</p>\n<p>那么，Parse到底是什么？</p>\n<p>三个字就可以概括：去后端。</p>\n<p>Parse服务其实已经推出很多年了，在4年前被Facebook 8500万美元收购，在去年被Facebook开源，但是在国内几乎一直无人问津。</p>\n<p>国内同类的服务平台，即BasS(Backend as a Service)服务平台主流的有Leancloud、Bmob。</p>\n<p>其中Leancloud我使用过，Bmob也注册过。Leancloud达到免费阈值以后的收费方案是每天最低消费30元，Bmob达到免费阈值以后的收费方案有99元/月的套餐。对于原型开发阶段的应用，其服务的免费额度使用还是绰绰有余的。</p>\n<p>就像刚才说的，BaaS服务就是去后端，也就是说，后端几乎完全不需要你自己开发了，数据库、用户系统、安全系统、Hook回调、API查询等都为你搭建好了。而且，比你搭建的还好。你只需要在项目中集成SDK，然后直接调用方法传参就可以完成前后端交互。</p>\n<p>打个比方，我要写一个按钮的用户注册方法：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;集成SDK\nimport parse from &#x27;parse&#x27;\nparse.serverURL = &#x27;http:&#x2F;&#x2F;localhost:2018&#x2F;parse&#x27;\nparse.initialize(&#x27;myAppId&#x27;, &#x27;123456&#x27;)\n\n&#x2F;&#x2F;在按钮点击实践中调用注册方法：\nbutton.on(&#x27;click&#x27;,function(username,password){\n  let user = new parse.User()\n  user.set(&#x27;username&#x27;, &#x27;000001&#x27;)\n  user.set(&#x27;password&#x27;, &#x27;lzhlmcl,yhblsqt&#x27;)\n  user.set(&#x27;email&#x27;, &#x27;xxxxx@qq.com&#x27;)\n  user.signUp().then(user =&gt; {\n  alert(&#x27;注册成功&#x27;)\n}).catch(console.error)\n})\n</code></pre><p>完成！</p>\n<p>只需要十几行代码，不需要写后端和接口。当上面代码弹出注册成功后，后台还会发送验证邮箱的邮件给用户，然后后台数据库就会出现新注册的用户。</p>\n<p>怎么样，so easy吧。</p>\n<p>简直就是，前端抢后端饭碗系列。</p>\n<p>当然了，使用Leancloud、Bmob这样的商业服务平台，数据是存储在他们的服务器上的。使用Parse自己搭建后端，则是保存在自己的服务器上。</p>\n<p>对比一下：</p>\n<p>Parse开源，数据库绝对私有，完全免费，这是Parse的优点。</p>\n<p>Leancloud、Bmob则是本地化做的非常优秀，比如对微信接口、短信验证的集成，这是他们的优点。</p>\n<p>上述优点，双方都不具备对方的优点，所以，让你选的话，你选胸大的还是腿长的？</p>\n<p>我一般是结合业务，如果我觉得这个应用就是玩玩，肯定做不大，为了省去维护和服务器维护，我会选择使用Leancloud，Bmob不熟练。如果说这个应用以后会有很大访问量，打算认真做做，预期会超过L、B的免费额度，出于平穷限制，我会选择Parse。</p>\n<p>不管你选择哪个，Parse其实都值得你掌握的。</p>\n<p>身为一个前端，如果你会使用L、B，首先也是不错的，至少开发效率很高了；不过，依赖于第三方商业平台，还是不够独立，算不得全栈开发者。如果你会使用Parse，你就相当于快速掌握了一种后端技术栈，算得上是全栈了。</p>\n<p>我为什么这么推荐Parse，并把Parse的文档翻译中文，整合详细的教程和实例呢？Parse是一个开源项目，也不是我的项目，我就是非常喜欢这类框架，你知道，发现一个好东西，总是特别想推荐给朋友们的。</p>\n<p>接下来，我还会继续写几个教程和例子，虽然，不是非常必要，有的人文档过一遍就会用了。</p>\n<p>最后附上<a href=\"https://parse-zh.buzhundong.com/\">Parse JavaScript SDK中文文档地址</a>。</p>\n</div>",
    "title": "[文档翻译] 全栈速成，最适合前端的后端服务框架： Parse",
    "last_reply_at": "2018-01-29T01:51:50.917Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 533,
    "create_at": "2018-01-26T16:25:18.585Z",
    "author": {
        "loginname": "jaweii",
        "avatar_url": "https://avatars3.githubusercontent.com/u/22613580?v=4&s=120"
    }
}, {
    "id": "5a6a8542ce45d440451463b6",
    "author_id": "580ffe64eae2a24f34e67ee1",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>TypeError: db.collection is not a function</p>\n<p>之后在连接数据库回调中加入 var mydb = db.db(‘myDatabaseNameAsAString’);\n参考：<a href=\"https://stackoverflow.com/questions/43779323/typeerror-db-collection-is-not-a-function\">https://stackoverflow.com/questions/43779323/typeerror-db-collection-is-not-a-function</a>\n<a href=\"https://mongodb.github.io/node-mongodb-native/api-generated/mongoclient.html\">https://mongodb.github.io/node-mongodb-native/api-generated/mongoclient.html</a>\n不太清楚这么写是为什么?</p>\n<p>具体代码:\nvar MongoClient = require(‘mongodb’).MongoClient;\nvar assert = require(‘assert’);\nvar url = ‘mongodb://localhost:27017/test’;\nvar insertDocument = function(db, callback) {\ndb.collection(‘restaurants’).insertOne( {\n“address” : {\n“street” : “2 Avenue”,\n“zipcode” : “10075”,\n“building” : “1480”,\n“coord” : [ -73.9557413, 40.7720266 ]\n},\n“borough” : “Manhattan”,\n“cuisine” : “Italian”,\n“grades” : [\n{\n“date” : new Date(“2014-10-01T00:00:00Z”),\n“grade” : “A”,\n“score” : 11\n},\n{\n“date” : new Date(“2014-01-16T00:00:00Z”),\n“grade” : “B”,\n“score” : 17\n}\n],\n“name” : “Vella”,\n“restaurant_id” : “41704620”\n}, function(err, result) {\nassert.equal(err, null);\nconsole.log(“Inserted a document into the restaurants collection.”);\ncallback();\n});\n};\n// 连接数据库\nMongoClient.connect(url, function(err, db) {\nassert.equal(null, err);\nconsole.log(‘Connected correctly to server.’,db);\nvar mydb = db.db(‘myDatabaseNameAsAString’);\n// 插入数据\ninsertDocument(mydb, function() {\ndb.close();\n});\n});</p>\n</div>",
    "title": "使用 mongodb 遇到的db.collection is not a function",
    "last_reply_at": "2018-01-29T01:29:36.248Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 327,
    "create_at": "2018-01-26T01:32:50.838Z",
    "author": {
        "loginname": "fairyly",
        "avatar_url": "https://avatars1.githubusercontent.com/u/17672815?v=4&s=120"
    }
}, {
    "id": "59f98c34c8ef9425668ac1fe",
    "author_id": "4f447c2f0a8abae26e01b27d",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>async function rejectionWithReturnAwait () {\n  try {\n    return await Promise.reject(new Error());\n  } catch (e) {\n    return &#x27;Saved!&#x27;;\n  }\n}\n\nasync function rejectionWithReturn () {\n  try {\n    return Promise.reject(new Error());\n  } catch (e) {\n    return &#x27;Saved!&#x27;;\n  }\n}\n</code></pre></div>",
    "title": "Node 8 LTS 有 async 了很兴奋？ 来，说说这 2 段代码的区别。",
    "last_reply_at": "2018-01-28T23:04:21.964Z",
    "good": false,
    "top": false,
    "reply_count": 23,
    "visit_count": 2479,
    "create_at": "2017-11-01T08:56:20.080Z",
    "author": {
        "loginname": "atian25",
        "avatar_url": "https://avatars1.githubusercontent.com/u/227713?v=3&s=120"
    }
}, {
    "id": "58d0dd8b17f61387400b7de5",
    "author_id": "575eaa97c1518403160a45c4",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h1><a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a></h1>\n<p>Easy-Monitor是一个轻量级的Node项目性能监控工具，能在线上生产环境运行，主要帮助开发者找出执行时间最久或者超出预期的一系列函数，以及运行过程中v8引擎无法优化的一系列函数。</p>\n<p>这个项目源于之前做的解析v8-profiler日志命令行工具，有兴趣的可以看下之前的文章：</p>\n<p><a href=\"https://cnodejs.org/topic/58b562f97872ea0864fee1a7\">手把手测试你的JS代码性能</a></p>\n<p>按照之前所说的方式，对于开发者来说依旧非常的麻烦，并且不能进行线上运行时的调试，所以就整合集成了下诞生了Easy-Monitor。</p>\n<h2>I. 特点</h2>\n<ul>\n<li><strong>轻量级</strong></li>\n<li><strong>运行时</strong></li>\n<li><strong>无状态</strong></li>\n<li><strong>支持线上的cluster模式和多项目部署</strong></li>\n</ul>\n<h2>II. 三步快速开始</h2>\n<h3>安装</h3>\n<p>在控制台执行下面的命令安装：</p>\n<pre class=\"prettyprint language-bash\"><code>npm install easy-monitor\n</code></pre><h3>项目中引入</h3>\n<p>在你的项目入口文件中按照如下方式引入，传入你的项目名称：</p>\n<pre class=\"prettyprint language-js\"><code>const easyMonitor = require(&#x27;easy-monitor&#x27;);\neasyMonitor(&#x27;你的项目名称&#x27;);\n</code></pre><h3>访问监控页面</h3>\n<p>打开你的浏览器，输入以下地址，即可看到进程相关信息：</p>\n<pre class=\"prettyprint language-bash\"><code>http:&#x2F;&#x2F;127.0.0.1:12333\n</code></pre><p>以上三步即可开启你的专属性能监控服务，非常简单！</p>\n<h2>III. 定制化</h2>\n<p><code>Easy-Monitor</code> 也为大家保留了一些重要的属性可以方便定制化，依靠执行 <code>require('easy-monitor')(object)</code> 函数时传入一个对象，来替代默认传入的项目名称的字符串，这个传入的对象可以包含如下属性：</p>\n<ul>\n<li>\n<p><strong>logLevel</strong>：Number类型，默认是2，用来设置日志级别：</p>\n<ul>\n<li>0：不输出任何日志</li>\n<li>1：输出error日志</li>\n<li>2：输出info日志</li>\n<li>3：输出debug日志</li>\n</ul>\n</li>\n<li>\n<p><strong>appName</strong>：String类型，默认是 process.title 获取到的值，用来设置项目名称</p>\n</li>\n<li>\n<p><strong>httpServerPort</strong>：Numver类型，默认是 12333，用来设置监控HTTP服务器的侦听端口</p>\n</li>\n<li>\n<p><strong>filterFunction</strong>：函数，默认将profiling的结果中过滤掉了包含node_modules、anonymous以及路径中不包含 “/” 的系统函数，开发者可以自己编写过滤函数来找出自己想要的结果，入参和返回值：</p>\n<ul>\n<li>filePath：String类型，profiling结果函数所在的文件全路径</li>\n<li>funcName：String类型，pfofiling结果函数的名称</li>\n<li>返回值：为true表示保留结果，false表示过滤掉</li>\n</ul>\n</li>\n<li>\n<p><strong>monitorAuth</strong>：函数，默认不鉴权，用来进行登入监控页面的鉴权，开发者可以自己编写鉴权函数，入参和返回值：</p>\n<ul>\n<li>user：String类型，为用户名</li>\n<li>pass：String类型，为用户键入密码</li>\n<li>返回值：Promise对象实例，resolve(true)表示鉴权通过，resolve(false)或者reject表示鉴权失败</li>\n</ul>\n</li>\n</ul>\n<h2>IV. 监控页面一览</h2>\n<h3>1. 首页</h3>\n<h4>a. 查看整个项目</h4>\n<p><img src=\"//dn-cnode.qbox.me/FnOnNJjc9AsVOMZqevsHqlns7K47\" alt=\"Index_Project.jpeg\"></p>\n<p>如图，点击项目名称，则会对 <strong>整个项目</strong> 所有的进程进行profiling操作，这个所有进程包含：</p>\n<ul>\n<li>单进程模式下则只有一个主进程</li>\n<li>cluster模式下所有的子进程</li>\n</ul>\n<h4>b. 查看项目下某一个子进程</h4>\n<p><img src=\"//dn-cnode.qbox.me/FoW6H8QpWmFDWxEGid4LzXQfL6_I\" alt=\"Index_Pid.jpeg\"></p>\n<p>如图，在cluster模式下项目会有多个子进程，点击某一个特定的pid，则只会对 <strong>此pid对应的子进程</strong> 进行profiling操作。</p>\n<h4>c. 多项目部署</h4>\n<p><img src=\"//dn-cnode.qbox.me/FmR6Bv32tyZR6Rf1yYIy9OF0PKxr\" alt=\"Index_Multi.jpeg\"></p>\n<p>如图，<code>Easy-Monitor</code> <strong>支持多项目部署</strong>，用法和单项目是一模一样的，可以参考前面的快速开始。那么多项目启动后，监控页面会展示出不同的项目名称和对应的子进程pid。</p>\n<h3>2. 监控详情页</h3>\n<h4>a. 执行时间超出预期的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FlaESADt9AZ3ohKXwQeiTfJvCLY7\" alt=\"Detail_Long.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义预期时间以及展示的条数，如下：</p>\n<ul>\n<li><code>?timeout=你预期的时间(ms)</code></li>\n<li><code>?long_limit=你想展示的条数</code></li>\n<li><code>?timeout=你预期的时间(ms)&amp;long_limit=你想展示的条数</code></li>\n</ul>\n<h4>b. 耗费时间最久的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FhpDcFU36iEYUkxC3nvv9bIrRlDY\" alt=\"Detail_Top.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义展示条数，如下：</p>\n<ul>\n<li><code>?top_limit=你想展示的条数</code></li>\n</ul>\n<h4>c. v8引擎无法优化的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FrBFxsxO8Vle6LFcSha4V10M2lz1\" alt=\"Detail_Bail.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义展示条数，如下：</p>\n<ul>\n<li><code>?bail_limit=你想展示的条数</code></li>\n</ul>\n<h2>V. 测试</h2>\n<p><a href=\"https://github.com/hyj1991/easy-monitor\">git clone</a>下本代码后，使用npm安装依赖，然后执行如下测试脚本：</p>\n<pre class=\"prettyprint\"><code>npm run test\n</code></pre><p>即可看到覆盖率测试报告。</p>\n<h2>VI. 结语</h2>\n<p>最后项目地址为：<a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a></p>\n<p>欢迎大家提issue，或者一起开发完善，如果感觉不错，赏个star也是很开心的事情~</p>\n</div>",
    "title": "轻量级易部署Node性能监控工具：Easy-Monitor",
    "last_reply_at": "2018-01-28T15:59:20.720Z",
    "good": false,
    "top": false,
    "reply_count": 27,
    "visit_count": 6298,
    "create_at": "2017-03-21T08:00:11.803Z",
    "author": {
        "loginname": "hyj1991",
        "avatar_url": "https://avatars2.githubusercontent.com/u/19908330?v=4&s=120"
    }
}, {
    "id": "5a6c1d4c9288dc81532882af",
    "author_id": "5a6c18f59288dc81532882ac",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>求一些2018年的前端面试题及侧重的知识点；\n近几年，前端知识迭代很快，面试题也需要推陈出新一下，担心知识点考察不到位</p>\n</div>",
    "title": "求一些2018年的前端面试题及侧重的知识点",
    "last_reply_at": "2018-01-28T15:49:40.888Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 415,
    "create_at": "2018-01-27T06:33:48.627Z",
    "author": {
        "loginname": "andyiwen",
        "avatar_url": "https://avatars0.githubusercontent.com/u/18592006?v=4&s=120"
    }
}, {
    "id": "5a6c699aafa0a121784a9073",
    "author_id": "598bba38396b25140b58cce4",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h2>jade(pug)</h2>\n<p>由于商标版权问题，Jade 已经改名为了 Pug,github地址<a href>https://github.com/pugjs/pug</a></p>\n<p>Jade 是一个高性能的模板引擎，它是用 JavaScript 实现的，并且可以供 Node 使用,当然还支持其他语言。</p>\n<p>文件后缀名为.pug(.jade)</p>\n<h2>jade优点</h2>\n<ul>\n<li>可读性高</li>\n<li>灵活的缩进</li>\n<li>块展开</li>\n<li>代码默认经过编码处理(转义),安全性高</li>\n<li>运行时和编译时上下文错误报告</li>\n<li>支持命令行编译</li>\n<li>支持html5模式</li>\n<li>在内存中缓存(可选)</li>\n<li>原生支持 Express</li>\n<li>合并动态和静态标签类</li>\n<li>过滤器</li>\n</ul>\n<p>关于Ejs或者其他模板引擎与jade比较,可以看看这篇文章<a href>https://www.zhihu.com/question/20355486</a></p>\n<h2>安装</h2>\n<p>npm安装建议安装个nrm来进行源管理.</p>\n<pre class=\"prettyprint\"><code>npm install pug -g\nnpm install pug-cli -g\n</code></pre><h2>测试demo</h2>\n<p>为了方便编写代码,最好把编译器的tab设置:2.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; index.jade\n\ndoctype html\nhtml\n  head\n    title jade test\n  body\n    h2 jade study    \n</code></pre><h5>粗暴的编译方法</h5>\n<pre class=\"prettyprint\"><code>pug index.jade\n\n&#x2F;&#x2F; index.html\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;jade test&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h2&gt;jade study    &lt;&#x2F;h2&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n</code></pre><p>发现编译后的代码不具备可读性.</p>\n<pre class=\"prettyprint\"><code>pug -- help\n Options:\n     -P, --pretty           compile pretty HTML output ## 输出漂亮结构的HTML\n    -D, --no-debug         compile without debugging (smaller functions) ## 不带调试的编译\n    -w, --watch            watch files for changes and automatically re-render ## 对某个文件的变动保持监控\n    -E, --extension &lt;ext&gt;  specify the output file extension ## 指定输出文件扩展名\n    -s, --silent           do not output logs ## 不输出日志\n   \n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 重新编译\npug -P index.jade\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;jade test&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h2&gt;jade study    &lt;&#x2F;h2&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><h5>自动编译</h5>\n<p>只是为了学习,这里只要设置-w -P .开发中通过打包工具来进行自动编译.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 命令行工具推荐使用Cmder\n\nλ pug -P -w index.jade\n  watching index.jade\n  rendered index.html\n</code></pre><h2>Express与Pug</h2>\n<p>Pug完全集成了一个流行的Node.js Web框架Express，作为支持的视图引擎。 看看Express是如何将Pug与Express集成的完美指南。</p>\n<p>在Express中，环境变量NODE_ENV旨在向Web应用程序通知执行环境：无论是在开发中还是在生产中。 Express和Pug自动修改生产环境中的几个选项的默认值，为用户提供更好的开箱即用体验。 具体来说，当process.env.NODE_ENV设置为“production”，Pug与Express一起使用时，compileDebug选项默认为false，而cache选项为true。</p>\n<h2>API</h2>\n<h5>标签属性</h5>\n<ul>\n<li>id,class写法</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n  p.title class写法1\n  p(class=&#x27;title&#x27;) class写法2\n  p#tit id写法1\n  p(id=&#x27;tit2&#x27;) id写法2     \n  \n&#x2F;&#x2F; 编译后\n  &lt;p class=&quot;title&quot;&gt;class写法1&lt;&#x2F;p&gt;\n  &lt;p class=&quot;title&quot;&gt;class写法2&lt;&#x2F;p&gt;\n  &lt;p id=&quot;tit&quot;&gt;id写法&lt;&#x2F;p&gt;\n  &lt;p id=&quot;tit2&quot;&gt;id写法2 &lt;&#x2F;p&gt;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var classArr = [&#x27;small&#x27;,&#x27;medium&#x27;,&#x27;large&#x27;]\na(class= classArr)\na.test(class = classArr class=[&#x27;add&#x27;])\n\n&#x2F;&#x2F; 编译后\n&lt;a class=&quot;small medium large&quot;&gt;&lt;&#x2F;a&gt;\n&lt;a class=&quot;test small medium large add&quot;&gt;&lt;&#x2F;a&gt;\n</code></pre><p>它也可以是将类名映射到true或false值的对象.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;编译前\n- var active = &#x27;select&#x27;\na(class={active: active === &#x27;select&#x27;} )\n\n&#x2F;&#x2F; 编译后\n&lt;a class=&quot;active&quot;&gt;&lt;&#x2F;a&gt;\n</code></pre><ul>\n<li>其他属性\n通过()来依次编写属性,多个用逗号隔开.</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;编译前\na(class=&#x27;baidu&#x27; ,title=&#x27;baidu&#x27; href=&#x27;www.baidu.com&#x27;) 百度\n\n&#x2F;&#x2F;编译后\n&lt;a class=&quot;baidu&quot; title=&quot;baidu&quot; href=&quot;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;\n</code></pre><ul>\n<li>也支持所有正常的javascript表达式</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var flag  = true   &#x2F;&#x2F;注意这里使用变量要记得添加-符号.\nh2(class=flag ? &#x27;flag&#x27;: &#x27;&#x27;)\n\n&#x2F;&#x2F; 编译后\n&lt;h2 class=&quot;flag&quot;&gt;&lt;&#x2F;h2&gt;\n</code></pre><ul>\n<li>多个属性的另外写法</li>\n</ul>\n<p>其实就是换号缩进</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\na(\n      title=&#x27;baidu&#x27;,\n      href=&#x27;www.baidu.com&#x27;,\n      class=&#x27;links&#x27;\n)\n&#x2F;&#x2F; 编译后\n&lt;a class=&quot;links&quot; title=&quot;baidu&quot; href=&quot;www.baidu.com&quot;&gt;&lt;&#x2F;a&gt;\n</code></pre><p>如果您有一个非常长的属性，并且您的JavaScript运行时支持ES2015模板字符串，则可以使用该语法的属性：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\ninput(data-json=&#96;\n      {\n        &quot;very-long&quot;: &quot;piece of &quot;,\n        &quot;data&quot;: true\n      }\n&#96;)\n&#x2F;&#x2F; 编译后\n&lt;input data-json=&quot;\n      {\n        &amp;quot;very-long&amp;quot;: &amp;quot;piece of &amp;quot;,\n        &amp;quot;data&amp;quot;: true\n      }\n&quot;&gt;\n</code></pre><ul>\n<li>引用属性</li>\n</ul>\n<p>如果你的属性名称包含了与JavaScript语法冲突的字符，请使用&quot;&quot;或’'引用，或使用逗号分隔不同的属性。</p>\n<p>官网举了个Angular 2的例子.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;(click)=&#x27;play()&#x27;,这里(click)会被当作一个函数调用而不是一个属性名字来解析.\n\n&#x2F;&#x2F; 编译前\ndiv(class=&#x27;div-class&#x27; (click)=&#x27;play()&#x27;)\n\n&#x2F;&#x2F; 编译后报错\ndiv(class=&#x27;div-class&#x27; (click)=&#x27;play()&#x27;)\n---------------------^\n</code></pre><p>正确写法</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\ndiv(class=&#x27;div-class&#x27; &#x27;(click)&#x27;=&#x27;play()&#x27;)\ndiv(class=&#x27;div-class&#x27;, (click) = &#x27;play()&#x27;)\n\n&#x2F;&#x2F; 编译后\n&lt;div class=&quot;div-class&quot; (click)=&quot;play()&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div class=&quot;div-class&quot; (click)=&quot;play()&quot;&gt;&lt;&#x2F;div&gt;\n</code></pre><ul>\n<li>属性插值</li>\n</ul>\n<p>以前版本的Pug / Jade支持如下插值语法(不再支持):</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;编译前\n- var url = &#x27;www.baidu.com&#x27;\na(href=&#x27;&#x2F;#{url}&#x27;) links\n\n&#x2F;&#x2F;编译后 已不再支持\n&lt;a href=&quot;&#x2F;#{url}&quot;&gt;links&lt;&#x2F;a&gt;\n</code></pre><p>新的写法</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var url = &#x27;demo.com&#x27;\na(href=&#x27;&#x2F;&#x27; + url) links\n- var url2 = &#x27;www.baidu.com&#x27;\na(href = url2 ) 百度  \n\n&#x2F;&#x2F; 编译后\n&lt;a href=&quot;&#x2F;demo.com&quot;&gt;links&lt;&#x2F;a&gt;\n&lt;a href=&quot;www.baidu.com&quot;&gt;百度  &lt;&#x2F;a&gt;\n</code></pre><p>如果你的javascript运行环境支持ES 2015.那么Pug支持模板字符串语法</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var size1 = &#x27;small&#x27;\n- var size2 = &#x27;medium&#x27;\n- var size3 = &#x27;large&#x27;\nbutton(\n  type=&#x27;button&#x27;,\n  class=&#x27;btn btn-&#x27; + size1 + &#x27; &#x27; +  &#x27;btn-&#x27; + size2 + &#x27; &#x27; + &#x27;btn-&#x27; + size3\n)\nbutton(\n  type=&#x27;button&#x27;,\n  class=&#96;btn btn-$(size1) btn-$(size2) btn(size3)&#96;\n)\n&#x2F;&#x2F; 编译后\n&lt;button class=&quot;btn btn-small btn-medium btn-large&quot; type=&quot;button&quot;&gt;&lt;&#x2F;button&gt;\n&lt;button class=&quot;btn btn-small btn-medium btn-large&quot; type=&quot;button&quot;&gt;&lt;&#x2F;button&gt;\n</code></pre><ul>\n<li>未转义属性</li>\n</ul>\n<p>默认情况下，会转义所有属性（用转义序列代替特殊字符），以防止诸如跨站点脚本之类的攻击。 如果必须需要使用特殊字符，可以使用！=而不是=。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\ndiv(title=&quot;&lt;code&gt;&quot;)\ndiv(title!=&quot;&lt;code&gt;&quot;)\n\n&#x2F;&#x2F; 编译后\n&lt;div title=&quot;&amp;lt;code&amp;gt;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div title=&quot;&lt;code&gt;&quot;&gt;&lt;&#x2F;div&gt;\n</code></pre><ul>\n<li>布尔属性</li>\n</ul>\n<p>布尔属性由Pug镜像，并接受布尔值（true和false）。 当没有指定值时，默认为true。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\ninput(type=&#x27;radio&#x27; checked)\ninput(type=&#x27;radio&#x27; checked=true)\ninput(type=&#x27;radio&#x27; checked=false)\n    \n&#x2F;&#x2F; 编译后\n&lt;input type=&quot;radio&quot; checked&gt;\n&lt;input type=&quot;radio&quot; checked&gt;\n&lt;input type=&quot;radio&quot;&gt;\n</code></pre><ul>\n<li>style属性</li>\n</ul>\n<p>style属性可以是一个字符串（像任何普通属性），但它也可以是一个对象</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\np(style={fontSize: &#x27;14px&#x27;,color: &#x27;red&#x27;})\n\n&#x2F;&#x2F; 编译后\n&lt;p style=&quot;fontSize:14px;color:red;&quot;&gt;&lt;&#x2F;p&gt;\n</code></pre><h5>Case</h5>\n<p>case语句是JavaScript Switch语句的缩写，并采用以下形式：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var friendsNum = 4\n    case friendsNum\n      when 0\n        p you have not friend\n      when 1\n        p you has one friend\n      default\n        p you has #{friendsNum} friends    \n        \n&#x2F;&#x2F; 编译后\n&lt;p&gt;you has 4 friends    &lt;&#x2F;p&gt;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var friendsNum = 1\n    case friendsNum\n      when 0\n      when 1\n        p you has one friend\n      default\n        p you has #{friendsNum} friends\n        \n&#x2F;&#x2F; 编译后\n&lt;p&gt;you has one friend&lt;&#x2F;p&gt;\n</code></pre><p>当然也支持break;</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n- var friendsNum = 0\n    case friendsNum\n      when 0\n        - break\n      when 1\n        p you has one friend\n      default\n        p you has #{friendsNum} friends\n        \n&#x2F;&#x2F; 编译后\n无内容\n</code></pre><p>也可以使用块扩展语法</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n  - var friendsNum = 1\n    case friendsNum\n      when 0\n      when 1: p you has one friend\n      default: p you has #{friendsNum} friends\n      \n&#x2F;&#x2F; 编译后\n&lt;p&gt;you has one friend&lt;&#x2F;p&gt;\n\n</code></pre><h5>Code</h5>\n<p>Pug可以在你的模板中编写内置的JavaScript代码。 有三种类型的代码。</p>\n<ul>\n<li>Unbuffered Code\n不直接添加任何的输出</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- for(var i = 0; i &lt; 3;i++)\n      li item\n      \n&#x2F;&#x2F; 编译后\n&lt;li&gt;item&lt;&#x2F;li&gt;\n&lt;li&gt;item&lt;&#x2F;li&gt;\n&lt;li&gt;item&lt;&#x2F;li&gt;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n- var nameList = [&#x27;kobe&#x27;,&#x27;cpul&#x27;,&#x27;james&#x27;]\n      each item in nameList\n        li=item\n        \n&#x2F;&#x2F; 编译后\n\n&lt;li&gt;kobe&lt;&#x2F;li&gt;\n&lt;li&gt;cpul&lt;&#x2F;li&gt;\n&lt;li&gt;james&lt;&#x2F;li&gt;\n</code></pre><ul>\n<li>Buffered Code</li>\n</ul>\n<p>以=开头，并输出评估模板中JavaScript表达式的结果。 为了安全起见，首先HTML被转义：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\np\n  = &#x27;this is code template &lt;code&gt;&#x27;\np= &#x27;this is code template&#x27; + &#x27;&lt;code&gt;&#x27;  \n\n&#x2F;&#x2F; 编译后\n\n&lt;p&gt;this is code template &amp;lt;code&amp;gt;\n&lt;&#x2F;p&gt;\n&lt;p&gt;this is code template&amp;lt;code&amp;gt;&lt;&#x2F;p&gt;\n</code></pre><ul>\n<li>Unescaped Buffered Code</li>\n</ul>\n<p>未转义的代码以！=开头，并输出评估模板中JavaScript表达式的结果。 这不会进行任何转义，所以对用户输入是不安全的：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\np\n  != &#x27;this is code template &lt;code&gt;&#x27;\np!= &#x27;this is code template&#x27; + &#x27;&lt;code&gt;&#x27;  \n\n&#x2F;&#x2F; 编译后\n&lt;p&gt;this is code template &lt;code&gt;\n&lt;&#x2F;p&gt;\n&lt;p&gt;this is code template&lt;code&gt;&lt;&#x2F;p&gt;\n</code></pre><h5>Comments注释</h5>\n<ul>\n<li>单行注释</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n&#x2F;&#x2F; 这是一个注释\np 这是一个注释\n\n&#x2F;&#x2F; 编译后\n\n&lt;!-- 这是一个注释--&gt;\n&lt;p&gt;这是一个注释&lt;&#x2F;p&gt;\n</code></pre><p>Pug还有种注释写法,只需添加连字符’-'即可。这些仅用于对Pug代码本身进行注释，编译后不会出现在HTML中。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n&#x2F;&#x2F;- 这是一个注释\np 这是一个注释\n    \n&#x2F;&#x2F; 编译后\n&lt;p&gt;这是一个注释&lt;&#x2F;p&gt;\n</code></pre><ul>\n<li>块级注释</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n&#x2F;&#x2F;-\n  注释不会出现在模板中\n  真的\n&#x2F;&#x2F;\n  第一行注释\n  第二行注释\n      \n&#x2F;&#x2F; 编译后\n\n&lt;!--\n    第一行注释\n    第二行注释\n--&gt;\n</code></pre><ul>\n<li>条件注释</li>\n</ul>\n<p>对于条件注释，Pug没有任何特殊的语法，下面例子这是为旧版本的Internet Explorer添加后备标记的特殊方法，但是由于以&lt;开头的所有行被视为纯文本，普通的HTML样式条件注释将会很好。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n&lt;!--[if IE 8]&gt;\n&lt;p class=&quot;lt-ie9&quot;&gt;\n&lt;![endif]--&gt;\n    \n&#x2F;&#x2F; 编译后\n\n&lt;!--[if IE 8]&gt;\n&lt;p class=&quot;lt-ie9&quot;&gt;\n&lt;![endif]--&gt;\n\n</code></pre><h5>Conditionals条件语句</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var user = {name: &#x27;kobe&#x27;}\n- var flag = true\n#user\n  if user.name\n    h3.user-title #{user.name}\n  else if flag\n    p flag is #{flag}\n  else\n    p default   \n    \n&#x2F;&#x2F; 编译后\n&lt;div id=&quot;user&quot;&gt;\n  &lt;h3 class=&quot;user-title&quot;&gt;kobe&lt;&#x2F;h3&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>Pug也支持另外一个关键字 unless</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var user = {name: &#x27;kobe&#x27;}\n#user\n  unless !user.name\n  h2 #{user.name}\n\n\n&#x2F;&#x2F; 编译后\n&lt;div id=&quot;user&quot;&gt;\n  &lt;h2&gt;kobe&lt;&#x2F;h2&gt;\n&lt;&#x2F;div&gt;\n</code></pre><h5>doctype</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\ndoctype html\n\n&#x2F;&#x2F; 编译后\n\n&lt;!DOCTYPE html&gt;\n\n</code></pre><h5>Filters过滤器</h5>\n<p>过滤器可让你在Pug模板中使用其他语言。也就是支持插件的使用,通过插件对模板内容进行过滤,处理,输出.如scss,less,markdown,coffee-script…</p>\n<p>先全局安装这些插件</p>\n<pre class=\"prettyprint\"><code>npm install --save jstransformer-coffee-script\nnpm install --save jstransformer-markdown-it\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\nh2 MarkDown\n  :markdown-it\n    #### this is markdown filter\n    [link](http:&#x2F;&#x2F;www.baidu.com)\n\n  :coffee-script\n    console.log(&#x27;this is coffee-script&#x27;);\n\n&#x2F;&#x2F; 编译后\n\n&lt;h2&gt;MarkDown&lt;&#x2F;h2&gt;&lt;h4&gt;this is markdown filter&lt;&#x2F;h4&gt;\n&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\n    (function() {\n  console.log(&#x27;this is coffee-script&#x27;);\n\n}).call(this);\n\n</code></pre><p>缺点:不能支持动态内容或选项。</p>\n<h5>Includes包含</h5>\n<p>Pug允许你静态包含一段 Jade, 或者别的存放在单个文件中的东西比如 CSS, HTML 非常常见的例子是包含头部和页脚。 假设我们有一个下面目录结构的文件夹：</p>\n<pre class=\"prettyprint\"><code>- &#x2F;index.jade\n- &#x2F;includes&#x2F;\n  -&#x2F;head.jade\n  -&#x2F;footer.jade\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; index.jade\ndoctype html\nhtml\n  include includes&#x2F;header.jade\n  body\n    h1 这是主题内容\n    include includes&#x2F;footer.jade  \n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; header.jade\nheader\n  title 通用的header\n  script(src=&#x27;&#x2F;jQuery.js&#x27;)\n  link(href=&#x27;reset.css&#x27;)\n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; footer.jade\nfooter#footer\n  p Copyright (c) foobar\n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译后\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;header&gt;\n    &lt;title&gt;通用的header&lt;&#x2F;title&gt;\n    &lt;script src=&quot;&#x2F;jQuery.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;link href=&quot;reset.css&quot;&gt;\n  &lt;&#x2F;header&gt;\n  &lt;body&gt;\n    &lt;h1&gt;这是主题内容&lt;&#x2F;h1&gt;\n    &lt;footer id=&quot;footer&quot;&gt;\n      &lt;p&gt;Copyright (c) foobar&lt;&#x2F;p&gt;\n    &lt;&#x2F;footer&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><p>include 可以包含比如 HTML 或者 CSS 这样的内容。给定一个扩展名后，Jade 不会把这个文件当作一个 Jade 源代码，并且会把它当作一个普通文本包含进来：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 格式\n\nstyle\n  include style.css\nscript\n  include script.js  \n</code></pre><p>甚至可以通过include结合过滤器使用</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 引入article.md\ninclude:markdown-it article.md\n</code></pre><h5>模板继承</h5>\n<p>Jade 支持通过 block 和 extends 关键字来实现模板继承。 一个块就是一个 Jade 的 block ，它将在子模板中实现，同时是支持递归的。</p>\n<p>如果需要，Pug block 可以提供默认内容，但是可以通过block scripts, block content, 和 block foot来显示如下所示的可选项。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 基本使用\n\n&#x2F;&#x2F; 编译前\nblock desc\n  p 这是block context\nblock desc  \n  \n&#x2F;&#x2F; 编译后\n&lt;p&gt;这是block context&lt;&#x2F;p&gt;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; index.jade\n\ndoctype html\nhtml\n  include includes&#x2F;header.jade\n  body\n    block content\n    block foot\n    .footer  some footer content\n\n</code></pre><p>现在要继承上面那个index.jade，只需创建一个新文件，并使用extend指令，如下所示，给出路径。 您现在可以定义一个或多个block将覆盖父块内容的块.</p>\n<p>在Pug v1中，如果没有给定文件扩展名，那么.pug会自动附加到路径上，但是在Pug v2中，这个行为已被弃用。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; index.jade\n\ndoctype html\nhtml\n  block scripts\n    script(src=&#x27;&#x2F;jquery.js&#x27;)\n  body\n    block content\n    block foot\n    .footer  some footer content\n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; page.jade\n\nextends index.jade\n\nblock scripts\n  script(src=&#x27;&#x2F;jquery.js&#x27;)\n  script(src=&#x27;&#x2F;page.js&#x27;)\n\nblock content\n  h2 page.jade\n  - var pets = [&#x27;cat&#x27;, &#x27;dog&#x27;]\n  each petName in pets\n    li=petName\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; page.jade 编译后\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;script src=&quot;&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src=&quot;&#x2F;page.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;body&gt;\n    &lt;h2&gt;page.jade&lt;&#x2F;h2&gt;\n    &lt;li&gt;cat&lt;&#x2F;li&gt;\n    &lt;li&gt;dog&lt;&#x2F;li&gt;\n    &lt;div class=&quot;footer&quot;&gt; some footer content&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><p>同样可以在一个子块里继续添加块，就像下面实现的块 content 里又定义了两个可以被实现的块 sidebar 和 primary，或者子模板直接实现 content。</p>\n<pre class=\"prettyprint\"><code>block content\n  .sidebar\n    block sidebar\n      p nothing\n  .primary\n    block primary\n      p nothing\n</code></pre><p>Pug允许你 替换 （默认）、 前置 和 追加 blocks. 使用 block append 或 block prepend 时 block 是可选的:</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; pageTwo.jade\n\nextend page.jade\n\nappend scripts\n  script(src=&#x27;&#x2F;pageTwo.js&#x27;)\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译后\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;script src=&quot;&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src=&quot;&#x2F;page.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src=&quot;&#x2F;pageTwo.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;body&gt;\n    &lt;h2&gt;page.jade&lt;&#x2F;h2&gt;\n    &lt;li&gt;cat&lt;&#x2F;li&gt;\n    &lt;li&gt;dog&lt;&#x2F;li&gt;\n    &lt;div class=&quot;footer&quot;&gt; some footer content&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><h5>Interpolation插值</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var author = &#x27;xyz&#x27;\n- var date = &#x27;2017-4&#x27;\nh2\n  p writer was by #{author.toUpperCase()}\n  p date is #{date}\n\n&#x2F;&#x2F; 编译后\n\n&lt;h2&gt;\n  &lt;p&gt;writer was by XYZ&lt;&#x2F;p&gt;\n  &lt;p&gt;date is 2017-4&lt;&#x2F;p&gt;\n&lt;&#x2F;h2&gt;\n</code></pre><p>如果你想保持#{}插值符号,可以使用#{或者’’.</p>\n<h5>Iteration迭代</h5>\n<ul>\n<li>each</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var arr = [1,2,3,4]\neach val,index in arr\n  li= index + &#x27;:&#x27; + val \n\n&#x2F;&#x2F; 编译后\n\n&lt;li&gt;0:1&lt;&#x2F;li&gt;\n&lt;li&gt;1:2&lt;&#x2F;li&gt;\n&lt;li&gt;2:3&lt;&#x2F;li&gt;\n&lt;li&gt;3:4&lt;&#x2F;li&gt;\n\n</code></pre><ul>\n<li>while</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var arr = 4\nwhile arr &gt; 0\n  li= arr--\n\n\n&#x2F;&#x2F; 编译后\n\n&lt;li&gt;4&lt;&#x2F;li&gt;\n&lt;li&gt;3&lt;&#x2F;li&gt;\n&lt;li&gt;2&lt;&#x2F;li&gt;\n&lt;li&gt;1&lt;&#x2F;li&gt;\n</code></pre><h5>Mixins</h5>\n<p>Mixins允许您创建可重用的Pug block。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\nmixin lists\n p this is a mixin block\n+lists\n+lists  \n\n&#x2F;&#x2F; 编译后\n\n&lt;p&gt;this is a mixin block&lt;&#x2F;p&gt;\n&lt;p&gt;this is a mixin block&lt;&#x2F;p&gt;\n</code></pre><p>mixins可以为一个带参数的函数</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\nmixin link(href,name)\n  a(href=href)= name\n\n+link(&#x27;www.baidu.com&#x27;,&#x27;百度&#x27;)  \n  \n&#x2F;&#x2F; 编译后\n\n&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;\n</code></pre><p>mixins也可以使用一个block来作为内容</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\nmixin lists(names)\n p= &#x27;my name is &#x27; + names\n if block\n   block\n else\n   p not provided content\n+lists(&#x27;kobe&#x27;)\n+lists(&#x27;cpul&#x27;)\n  p block content\n\n&#x2F;&#x2F; 编译后\n\n&lt;p&gt;my name is kobe&lt;&#x2F;p&gt;\n&lt;p&gt;not provided content&lt;&#x2F;p&gt;\n&lt;p&gt;my name is cpul&lt;&#x2F;p&gt;\n&lt;p&gt;block content&lt;&#x2F;p&gt;\n</code></pre><p>未知数量参数(…)的mixins.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\nmixin lists(className,...items)\n  ul(class=className)\n    each item in items\n      li= item\n\n+lists(&#x27;demo&#x27;,1,2,3)\n&#x2F;&#x2F; 编译后\n\n&lt;ul class=&quot;demo&quot;&gt;\n  &lt;li&gt;1&lt;&#x2F;li&gt;\n  &lt;li&gt;2&lt;&#x2F;li&gt;\n  &lt;li&gt;3&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n</code></pre><h5>Tags</h5>\n<p>默认情况下，一行开头的文本（或仅在空格之后）代表一个html标签。 缩进的标签是嵌套的，创建了像html的树结构。</p>\n<p>Pug可以判断出哪些元素是自闭,您还可以通过简单地附加’/'字符来明确地自己关闭标签：</p>\n<p>为了节省空间，Pug提供嵌套标记的内联语法。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\np: span 内联\n\n&#x2F;&#x2F; 编译后\n&lt;p&gt;&lt;span&gt;内联&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;\n</code></pre><h2>Pug的缺点</h2>\n<p>凡事不可能完美.Pug也有自己的弊端.</p>\n<ul>\n<li>可移植性差</li>\n<li>对新手调试不方便</li>\n<li>性能不是很好</li>\n</ul>\n<h4>原文.<a href=\"https://github.com/1657413883/blog-notes/issues/81\">https://github.com/1657413883/blog-notes/issues/81</a></h4>\n</div>",
    "title": "之前学习整理的pug文档. 社区虽然也有,但是都是很久之前的.因此分享一下,希望对新人有用.",
    "last_reply_at": "2018-01-28T07:42:40.180Z",
    "good": false,
    "top": false,
    "reply_count": 4,
    "visit_count": 286,
    "create_at": "2018-01-27T11:59:22.775Z",
    "author": {
        "loginname": "1657413883",
        "avatar_url": "https://avatars3.githubusercontent.com/u/17512533?v=4&s=120"
    }
}, {
    "id": "58c94ea659017af119c1d31b",
    "author_id": "54fed7b5c1749396754897ba",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>随着google translate api 的收费,有翻译需求的小伙伴都在与 google 斗智斗勇。</p>\n<p>网上流行一个翻译api，不需要获取google token，以get的方式调用。但大家都知道，get最大请求只有2048字符，远远不能满足小伙伴们的需求。那还有什么其他办法吗？难道真要去付费，楼主表示心在滴血！</p>\n<p>经过多次尝试，摸清了 google 翻译的规则，找出了token的计算方法。基于token能通过post方式调用翻译接口了，另外还基于爬虫抓取实现了网页翻译，解决了大多数的翻译需求。调用方法也超简单，不说了直接上代码。。。</p>\n<pre class=\"prettyprint language-javascript\"><code>\n  const translate = require(&#x27;translate-api&#x27;);\n\n  let transUrl = &#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;&#x27;;\n  translate.getPage(transUrl).then(function(htmlStr){\n    console.log(htmlStr.length)\n  });\n\n  let transText = &#x27;hello world!&#x27;;\n  translate.getText(transText,{to: &#x27;zh-CN&#x27;}).then(function(text){\n    console.log(text)\n  });\n\n\n</code></pre><p>示例项目： <a href=\"https://github.com/yixianle/google-translate\">https://github.com/yixianle/google-translate</a>\n在线演示： <a href=\"http://translate.hotcn.top/\">http://translate.hotcn.top/</a></p>\n</div>",
    "title": "给大家分享一个免费的谷歌翻译api",
    "last_reply_at": "2018-01-28T06:27:23.179Z",
    "good": false,
    "top": false,
    "reply_count": 9,
    "visit_count": 14246,
    "create_at": "2017-03-15T14:24:38.715Z",
    "author": {
        "loginname": "yixianle",
        "avatar_url": "https://avatars0.githubusercontent.com/u/11406512?v=4&s=120"
    }
}, {
    "id": "596c55e4af1a22d018d97042",
    "author_id": "596c546b8f05de0819fdb25d",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FkUaUJEGuq2fHJVLE-6mR0UiSWpr\" alt=\"QQ图片20170717141135.jpg\">\n从这里开始是我的nginx  nginx.conf的配置\n我需要怎么该这个配置呢？\n#user  nobody;\nworker_processes  2;</p>\n<p>#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;</p>\n<p>#pid        logs/nginx.pid;</p>\n<p>events {\nworker_connections  1024;\n}</p>\n<p>http {\ninclude       mime.types;\ndefault_type  application/octet-stream;</p>\n<pre class=\"prettyprint\"><code>#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;\n#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;\n#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;\n\n#access_log  logs&#x2F;access.log  main;\n\nsendfile        on;\n#tcp_nopush     on;\n\n#keepalive_timeout  0;\nkeepalive_timeout  65;\n\n#gzip  on;\n\nserver {\n    listen       80;\n    server_name  www.ycybl.com;\n\n    #charset koi8-r;\n\n    #access_log  logs&#x2F;host.access.log  main;\n\n    location &#x2F; {\n        root   html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              &#x2F;404.html;\n\n    # redirect server error pages to the static page &#x2F;50x.html\n    #\n    error_page   500 502 503 504  &#x2F;50x.html;\n    location = &#x2F;50x.html {\n        root   html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache&#x27;s document root\n    # concurs with nginx&#x27;s one\n    #\n    #location ~ &#x2F;\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n# another virtual host using mix of IP-, name-, and port-based configuration\n#\n#server {\n#    listen       8000;\n#    listen       somename:8080;\n#    server_name  somename  alias  another.alias;\n\n#    location &#x2F; {\n#        root   html;\n#        index  index.html index.htm;\n#    }\n#}\n\n\n# HTTPS server\n#\n#server {\n#    listen       443 ssl;\n#    server_name  localhost;\n\n#    ssl_certificate      cert.pem;\n#    ssl_certificate_key  cert.key;\n\n#    ssl_session_cache    shared:SSL:1m;\n#    ssl_session_timeout  5m;\n\n#    ssl_ciphers  HIGH:!aNULL:!MD5;\n#    ssl_prefer_server_ciphers  on;\n\n#    location &#x2F; {\n#        root   html;\n#        index  index.html index.htm;\n#    }\n#}\n</code></pre><p>}\nnginx.conf的配置结束</p>\n<p>我需要怎么该这个配置呢？</p>\n</div>",
    "title": "windows环境的服务器，部署nodejs，通过ngnix反向代理",
    "last_reply_at": "2018-01-28T01:41:31.885Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 1312,
    "create_at": "2017-07-17T06:15:00.570Z",
    "author": {
        "loginname": "newBird01",
        "avatar_url": "https://avatars3.githubusercontent.com/u/25924193?v=4&s=120"
    }
}, {
    "id": "5a6cbcb89288dc81532882c8",
    "author_id": "5a4edbe8ebc575dc49b27157",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>原文：<a href=\"http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/\">http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/</a></p>\n<p>HACKERNOON：<a href=\"https://hackernoon.com/understanding-the-react-source-code-vi-fe91ea58737f\">https://hackernoon.com/understanding-the-react-source-code-vi-fe91ea58737f</a></p>\n</div>",
    "title": "深入理解React源码 VI－英文预览版",
    "last_reply_at": "2018-01-27T17:54:00.557Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 310,
    "create_at": "2018-01-27T17:54:00.557Z",
    "author": {
        "loginname": "holmeshe",
        "avatar_url": "https://avatars3.githubusercontent.com/u/30769400?v=4&s=120"
    }
}]